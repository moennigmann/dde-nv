###########################################################################################
# SysIdent
#
# Methods to evaluate the least-squares identifiability of a
# ReactionNetwork
#
# important to Do: 1. improve error messages
#		   2. variable input works  only for the first parameter
#		   3. for ReduceModel change the procedure that calculate the hessian, so that they can
#		      pick the right sensitivities from the solution of the large model.
# Copyright (C) 2006 by T. Quaiser for
# Lehrstuhl f. Prozesstechnik,
# RWTH Aachen. All rights reserved.
# % functions are not used correctly in several error and other messages => change the order of %x.
###########################################################################################

SysIdent := module()

  export
      DeltaPhiAndLSQ,
      CreateODESolSen,
      CreateODESolSenAnal,
      CreateAnalyticHessian,
      CreateDotD,
      CompareAnalyticDDASPKSenHessian,
      SlidingWindowCalculation,
      StateODESysForDsolve,
      StateInitCondForDsolve,
      DoDDASPKSenStep,
      TransformDynamicVars,
      ExtendingWindowCalculation,
      CompareSeveral,
      listOfErrorsInOutputFunctions,
      listOfErrorsInInputList,
      IsCurveFromCreateODESolSen,
      CurveContainsVarsAndSensOfParams,
      CurveToListOfVectorsExt,
      CurveToListOfVectors,
      Lsq,
      ComputeEigenvectorsOfHessianForSelectedParameters,
      SelectSpecificColumnsFromMatrix,
      SelectLargestEntrieFromVectors,
      FindMaxAbsInVector,
      FindMinAbsInVector,
      CalculatePrioriParameterCorrelation,
      CalculateAbsoluteSumOfRow,
      CalculateSumOfSelectedValuesPerRow,
      ReduceModelOpt,
      CalculateGMatrix,
      CreateHessianForSelectedParameters,
      FindIndicesOfListElements,
      FindDegenringParameters,
      RemoveDegenringParameters,
      firstListNumericElementIsSmaller,
      FindParametersWithCompleteDegenringApproachV1,
      FindParametersWithCompleteDegenringApproachV2,
      FindParametersWithCompleteDegenringApproachV3,
      ListNumericIsLarger,
      FindParametersWithCompleteDegenringApproachV3_Array,
      FindDegenringParametersOpt,
      FindDegenringParametersOptOpt,
      FindParametersWithCompleteDegenringApproachV3_Opt,
      FindYaoParameter,
      FindYaoParameterOpt,
      CreateListOfParameterCombination,
      ComputeHessianEigenvaluesForSelectedParameters      
;



  local VariableInputHandler,firstListElementAbsIsLarger,firstListElementAbsIsSmaller;


      ##################################################################################################################
      # input: senParsList -> contains all sensitivity parameters
      #       varsList -> List of allowed variables
      #       outputFnctList -> list of equations, containing the response functions
      # output: a list of errors. An error occurs, when one of this condition is not satisfied:
      #                             1. at least one variable of varsList has to occur in each function of outputFnctList
      #                             2. names in each function has to be member of varsList and/or paramList
      ##################################################################################################################
      listOfErrorsInOutputFunctions:= proc(
        senParsList::list(name),
	varsList::list(name),
        outputFnctList::list(equation)
      )

      local flag,nrFunctions, errorList,evalFunct, hasAtLeast1Vars, subsTo1List, funct, vars, selectResult, nonNumeric, functString,
      varsString, senParamString,nonNumString;

           errorList:=[];
           nrFunctions:= nops(outputFnctList);
           hasAtLeast1Vars:=false;
           subsTo1List:=[];
           varsString:= convert(varsList, string);
           senParamString:=convert(senParsList, string);

          #
          # initialize subsTo1List; each element of senParsList and varsList is "dummy-set" equal to 1 for later substitution
          #
          subsTo1List:=[seq(senParsList[i]=1, i=1..nops(senParsList)),
	                seq(varsList[j]=1,j=1..nops(varsList))
			];

          #
          # check each function for legality
          #
          for funct in outputFnctList do:
            functString:=convert(funct,string);

            for vars in varsList do:
              if
	        has(funct, vars)
	      then
                hasAtLeast1Vars:=true;
                break;
              end if:
            end do:

            #
            #check if at Least one variable is in this function
            #
            if not
	      hasAtLeast1Vars
	    then
              errorList:= [op(errorList),
			  cat("in ",functString, " no variable out of ",varsString, " occurs.")
			  ];
            end if:

            evalFunct:=eval(rhs(funct),subsTo1List);

            #
            #check if there still exist a name in function
            #
            if
	      hastype(evalFunct,name)
	    then
              errorList:=[op(errorList),
                          cat("in ",functString, " there are names not from ", varsString," or " ,senParamString)
			  ];
            end if:
          end do:

          return errorList;

      end proc:


      ##################################################################################################################
      # input: aDAESys -> DAESys of interest
      #	       initTime -> start time of the integration
      #	       inputFctList -> list of tupels, ascending according their first coordinates
      # output: a list of errors. An error occurs, when one of this condition is not satisfied:
      #                             1. there is no non-Sensitivity parameter defined in DAESys 
      #                             2. inputFctList is empty
      #				    3. inputFctList is not ordered ascendingly according the firt coordinate
      #				    4. first coordinate of tupel is smaller than initTime 
      ##################################################################################################################
      listOfErrorsInInputList := proc(
	aDAESys::DAESys,			
        initTime::numeric,
	inputFctList::list([numeric,numeric])
      )

	local errorList, startTimeInput, endTimeInput,actTime, previousTime, w;   

          errorList := [];

	  #
	  #check if one non-Sensitivity paremeter is defined in DAESys 
	  #
	  if
	    (aDAESys[Parameters]=[])
	  then:
	    errorList:=[op(errorList),
			"An InputFctList is spezified, but there is no non-Sensitivity parameter in the actual DAESys"
			];
	  end if:

	  #
	  #type checking of additional parameter
	  #
	  if
	    (inputFctList=[])
	  then
	    errorList:=[op(errorList), "InputFctList is empty"];
	  else

	    #
	    #check if inputFctList is a list, which tupels occur in ascending order respective their first element
	    #
	    startTimeInput := inputFctList[1][1];
	    endTimeInput := inputFctList[nops(inputFctList)][1];
	    actTime := startTimeInput;
	    previousTime := startTimeInput-1;
	    for w from 1 to nops(inputFctList) do:
	      actTime:= inputFctList[w][1];
	      if
	        (w>1)
	      then
		previousTime:=inputFctList[w-1][1]:
	      end if:

	      if
		(actTime <= previousTime)
	      then:
	        errorList :=[op(errorList),
			    "inputFctList has to be a list of coordinates, ascending by its first coordinate"
			    ];
	      end if:
	    end do:

	    #
	    #inputFctList, has to define coordinates only for timepoints lager than initTime, the initValue for the Parameter has to be set
	    #already in DDASPKproc
	    #
 	    if
	      (startTimeInput <= initTime)
	    then
              errorList:=[op(errorList),
			  "inputFctList has to define coordinates only for timepoints larger than initTime"
			  ];
	    end if:

	  end if:
	  return errorList:
      
      end proc:

      ##################################################################################################################
      # input:
      # output:
      #	to do: document
      ##################################################################################################################
      IsCurveFromCreateODESolSen:= proc(resultCurve::`module`,
        listVars::list(name),
	listPars::list(name)
      )
        
	local errorList, allData, sensNames, allNames, varNames;

	errorList:=[];
	#
	#check if resultCurve is an instance of the curve module
	#
      	try
	  allData:= resultCurve:-GetData()
	catch:
	  errorList:= [op(errorList), lasterror];
	end try;

	#
	#create Sensitivitynames from listVars and listPars
	#
	sensNames:= { seq(
		        seq(
			  cat('d',listVars[n],'d', listPars[s]),
			  n = 1..nops(listVars)
			),
			s=1..nops(listPars)
		    )};

	#
	#put together the names of the dynamic variables and the sensitivities, that should be stored in the
	#curve object (parameter 1)
	#
	allNames:={op(sensNames), op(listVars), time};	    

	#
	#check if resultCurve contains all necessary elements (names of dynamic variables and sensitivities)
	#
	varNames:= resultCurve:-GetVarNames();
	varNames:= convert(varNames, set);
	
	if not
	  varNames  minus allNames = {}
        then
	  errorList:=[op(errorList), "Parameters and Variables specified via parameters do not correspond to the variables in the object containing the trajectories and sensitivities"];
	end:

	return errorList:
	 
      end proc:	




      ##################################################################################################################
      # input:  
      # output:
      #	to do: check if trajeSens is a result of CreateODESolSen. For each variable x from varsList and for each parameter p from
      #	       paramList there must be one sensitivity name of the format dxdp as table index in trajeSens. Furthermore all
      #	       variables from varsList must be index in trajeSens. It is not necessaty, that paramList contains all paramters, that
      #	       are available in trajeSens, as long as all paramters out of paramList are stored as dxdp for all x.
      ##################################################################################################################
      CurveContainsVarsAndSensOfParams:= proc(resultCurve::`module`,
        listVars::list(name),
	listPars::list(name)
      )
        
	local errorList, allData, sensNames, allNames, varNames, nrNames, diffNames, dynamicVars, nrVarsInTrajeSen;

	nonTableData:=resultCurve:-GetNonTableData();
	errorList:=[];
	#
	#check if resultCurve is an instance of the curve module
	#
      	try
	  allData:= resultCurve:-GetData()
	catch:
	  errorList:= [op(errorList), lasterror];
	end try;

	#
	#create Sensitivitynames from listVars and listPars
	#
	sensNames:= { seq(
		        seq(
			  cat('d',listVars[n],'d', listPars[s]),
			  n = 1..nops(listVars)
			),
			s=1..nops(listPars)
		    )};

	#
	#put together the names of the dynamic variables and the sensitivities, that should be stored in the
	#curve object (parameter 1)
	#
	allNames:={op(sensNames), op(listVars), time};
	nrNames:=nops(allNames);

	#
	#check if resultCurve contains all necessary elements (names of dynamic variables and sensitivities)
	#
	varNames:= resultCurve:-GetVarNames();
	varNames:= convert(varNames, set);
	nrVarsInTrajeSen:= nops(varNames);
	diffNames:=varNames minus allNames;

	#check if for every element in allNames, there is an equivalent in the names of trajeSens;
	if not
	  nops(diffNames)= (nrVarsInTrajeSen - nrNames)
        then
	  errorList:=[op(errorList),
	    "Parameters and Variables specified via input parameters of the function do not have an equivalent in the trajeSen input"
	  ];
	end:

	#to check, wether all variables occur in traje sens, as are specified in the input parameter varsList
	dynamicVars:= rhs(nonTableData[3]);
	if not
	  dynamicVars=[]
	then
	  if not
	    (convert(listVars,set) minus convert(dynamicVars,set)) ={}  
	  then
	    errorList:=[op(errorList), "All elements of listVars has to be specified in the resultCurvet"];
	  end if;
	end if:

	return errorList:
	 
      end proc:	


      ##################################################################################################################
      # input: trajeSens -> module of type Curve, has to be created with function CreateODESolSen
      #	       varsList -> to check, wether the trajeSens contains the right variables
      #	       senParsList -> selection of Parameters, for which the Hessian should be calculatedx
      #        startTime -> left border of integration
      #        endTime -> right border of integration
      #	       outputFnctList::list(equation) -> list of equations of the output
      # output: Hessian Matrix of Phi
      #		Matrix containing the derivatives of the response functions i (row) for each time point j (column) for
      #		selected Parameters
      #	documentation: the formula for calculating the Hessian matrix can be found at:
      #		       reposit\Maple\SysIdent\trunk\Formula_CreateHessian.pdf
      # todo1: check, that DDASPKproc is definitive a model of type DDASPKSen
      # todo2: untill now, one has to declare parameters of the output functions as sensitivity parameters in the creation
      #	       of an instance of DDASPKSen, although these parameters do  not appear in the instance of
      #	       DDASPKSen => all Sensitivities calculated for these parameters are zero => no problem for the calculation.
      #	       Only Create Hessian needs these additional parameters. An Idea is to create a new input parameter: outputParams
      #	       That contains those parameters exclusive to the output function.
      #	todo3: check if all Parms contain all parameters of the outputfunction; and the user has to be sure, that
      #	       the parameters in allParams are the same as used for trajeSens
      # comment: optimized version
      ##################################################################################################################
      CreateHessianForSelectedParameters:= proc(trajeSens::`module`,
	varsList::list(name),
	senParsList::list(name),
        startTime::numeric,	
	endTime::numeric,
        outputFnctList::list(equation)
      )

      local allParams, allParameterNames,nrParams, nrVars, hessianNum, generalHessian, jakobianPars,
        jakobianVars, i, j, hessianEntry,data, actState, k, nrFnct ,timePoints,
        sumOverTime,sumOverFunct ,VarsEqu ,l ,loopVars,m, sumOverVarsL,actJakobianParsL, n,actSensNameL,
	actSensValueL ,actJakobianVars,dgJdParamL, subsList, listOfErrors, errMsg, actDAESys, actStartPosition,
        f, actItem, inputFct, tmp, errList, allData, initTime, actEndPosition, startFlag, sizeTrajeSens,
	endTimeOfSolution, deltaGDeltaPL, nrTimePoints, p, actParam, a, counter1, counter2, counter3, r, s, nr1, nr2, actResult, actValue, actNr,
	deltaGMatrix ;


      #------------------------------------------------------------------------------------	
      #
      #define important variables
      #
      #------------------------------------------------------------------------------------	

      #
      #check if trajeSens is a result of CreateODESolSen. For each variable x from varsList and for each parameter p from
      #senParsList there must be one sensitivity name of the format dxdp as table index in trajeSens. Furthermore all
      #variables from varsList must be index in trajeSens.It is not necessaty, that senParsList contains all paramters, that
      #are available in trajeSens, as long as all paramters out of senParsList are stored as dxdp for all x.
      #
      errList:= CurveContainsVarsAndSensOfParams(trajeSens, varsList, senParsList);
      if  not
        errList=[]
      then
        ERROR(convert(errList, string));
      end:

      data:= trajeSens:-GetData();
      sizeTrajeSens:=trajeSens:-GetNumPoints();
     # actDAESys := DDASPKproc:-GetSys();
      nrVars := nops(varsList);
      nrParams:= nops(senParsList);
      nrFnct := nops(outputFnctList);
      initTime:= data[time][1];
      allParams:=trajeSens:-GetParameters();
      allParameterNames:=map(lhs,allParams);

      #------------------------------------------------------------------------------------	
      #
      #check if arguments are correct
      #
      #------------------------------------------------------------------------------------	

      #
      #check if last timepoint in trajeSens at least equals the parameter endTime
      #
      endTimeOfSolution:= data[time][sizeTrajeSens];
      if
        endTimeOfSolution < endTime
      then
        error("#of datapoints in second parameter has to be large than fifth parameter"); 
      end if:

      #
      #check wether the outputFnctList has the right format (see also documentation of listOfErrorsInOutputFunctions)
      #
      listOfErrors := listOfErrorsInOutputFunctions(allParameterNames,
        varsList,
	outputFnctList
      );

      #
      #if there has been an error, throw an exception with the corresponding message
      #
      if not
        listOfErrors=[]
      then
        errMsg:=convert(listOfErrors,string);
        error errMsg;
      end if:

      #
      #check if startTime is larger than initTime. startTime can only be larger than the initTime
      #
      if
	startTime < initTime
      then
	error("second parameter has to be larger then the fifth");
      end if:


      #------------------------------------------------------------------------------------	
      #
      #Get trajectories and sensitivities and create Jakobian
      #
      #------------------------------------------------------------------------------------	

      #
      #Get the number of points in trajeSens
      #
      timePoints:=trajeSens:-GetNumPoints();

      #
      #determine at which position in data[time] startTime and endTime is reached
      #
      actStartPosition:= 0;
      actEndPosition:=0;
      startFlag:=false:
      actStartPosition:=1;
      for f from 1 to timePoints do:
	actItem:= data[time][f];
	if
	  (actItem>= startTime and not startFlag)
	then
	  actStartPosition:=f;
	  startFlag:= true;
	elif
	  (actItem>= endTime)
	then
	  actEndPosition:= f;
	  break;
	end if:
      end do:

      #
      #Initialize hessianNum
      #
      hessianNum:=Matrix(1..nrParams, 1..nrParams, shape = symmetric);
      deltaGMatrix:= arrray(1..nrParams, 1..nrFnct, 1..timePoints);

      #
      #create Jakobian regarding the Parameters and regarding the variables
      #
      jakobianPars := linalg[jacobian](map(rhs, outputFnctList),senParsList);
      jakobianVars := linalg[jacobian](map(rhs, outputFnctList),varsList);

      #------------------------------------------------------------------------------------	
      #
      #fill Hessianmatrix; exploit the structure of the problem (symmetric matrix) to speed
      #up calculation
      #
      #------------------------------------------------------------------------------------

	  #
	  #initialize array to save the result of summing over time for each parmeterpair pi pj (with i<j) =>
	  #values for the sum regarding pj pi = value for the sum regarding pi pj; one only has to calculate the upper
	  #triangle of the matrix of parameters, because Matrix is symmetric
	  #
          sumOverTime:=array(1..(nrParams^2+nrParams)/2);
	  for a from 1 to (nrParams^2+nrParams)/2 do:
	    sumOverTime[a]:=0;
	  end do:
	  
	  #
	  #loop sums over Time
	  #
          for i from actStartPosition to actEndPosition do:

	    #
	    #initialize array to save the result of  summing over response functinos, again just save the upper triangle values 
	    #of the parameter matrix, because matrix is symmetric. 
	    #sequence of paremeters as follows [parameterindex1, parameterindex2]: [1,1]...[1,n]-----[i,i]...[i,n]-----[n-1,n-1]...[n-1,n]-----n:[n,n]
	    #with n= #parameters
	    #
	    sumOverFunct:=array(1..(nrParams^2+nrParams)/2);
	    for a from 1 to (nrParams^2+nrParams)/2 do:
	      sumOverFunct[a]:=0;
	    end do:

	    #
	    #VarsEqu saves the Values for the dynamic Variables at time i
	    #
	    VarsEqu:=array(1..nrVars);
	    nrTimePoints:= actEndPosition-actStartPosition +1:

	    #
	    #fill VarsEqu, containing equations: state=value, for substitution in the last loop (loop over state variables)
	    #
	    for tmp from 1 to nrVars do:
	      loopVars:= varsList[tmp]:
	      VarsEqu[tmp]:=loopVars=data[loopVars][i]:
	    end do:

	    #
	    #create subsList, for substitution in the last loop (loop over state variables) 
	    #
	    VarsEqu:=convert(VarsEqu, list):
	    subsList:=[op(VarsEqu),op(allParams)]:

	    #
	    #Sum over response functions
	    #
	    for j from 1 to nrFnct do:

	      #
	      #for fixed timePoint i and fixed responseFct j calculate for each parameter (p) deltaGDeltaPp and store in a an  array   
	      #
	      deltaGDeltaPL:=array(1..nrParams);

	      #
	      #for each parameter pl calculate for fixed time i and fixed response function j diff(gj(i),pl)
	      #
	      for l from 1 to nrParams do:
	      
	        actParam:= senParsList[l];
	        sumOverVarsL := 0;
	        actJakobianParsL := jakobianPars[j,l];

		#
		#Sum over statevariables, here subsList is needed
		#
		for m from 1 to nrVars do:
		  actState:= varsList[m];
		  actSensNameL := cat('d',actState,'d',actParam);	#create names ('dxdp') serving as indices for data table
		  actSensValueL := data[actSensNameL][i];
		  actJakobianVars := jakobianVars[j,m];

		  #
		  #calculate dg/dp's for fixed timePoint and fixed response function
		  #
		  sumOverVarsL := sumOverVarsL +subs(subsList,actJakobianVars)*actSensValueL;
		end do:
		#
		#add single term to the previous calculated sumOverVars
		#
		dgJdParamL := sumOverVarsL + subs(subsList,actJakobianParsL);

		#
		#store for fixed time and fixed respones function all diff(g)/diff(p)
		#
		deltaGDeltaPL[l]:=dgJdParamL:

		#
		#also store diff(g)/diff(p) for each time point in deltaGMatrix, I NEED A THREE DIMENSIONAL ARRAY (1..nrParam)
		#
		deltaGMatrix[funct][time]:= dgJdParamL:
	      end do:

	      #
	      #for each parameter pair pr ps from the upper triangle of the parametermatrix multiply both dgm/dpr and dgm/dps and sum all
	      #products over all function gj
	      #
	      counter1:= 0;
	      for r from 1 to nrParams do:
	        for s from r to nrParams do:
		  counter1:= counter1 +1;
		  sumOverFunct[counter1]:= sumOverFunct[counter1] + deltaGDeltaPL[r]*deltaGDeltaPL[s];
		end do:
	      end do:

            end do:  

	    #
	    #for each parameter pair pr ps from the upper triangle of the parametermatrix sum all sumOverFunction over all timepoints;
	    #counter keeps track of the right position in the arrays sumOverTime and sumOverFunct 
	    #
	    counter2:=0;
	    for r from 1 to nrParams do:
	      for s from r to nrParams do:
		counter2:= counter2 +1;
		sumOverTime[counter2]:= sumOverTime[counter2] + sumOverFunct[counter2];
	      end do:
	    end do:	 

       	  end do:


	  #
	  #fill appropiate values from the 1D array sumOverTime in the 2D array hessianNum; position are correct, because äquivalent loop
	  #structure is chosen
	  #
	  counter3:=0;
	  for nr1 from 1 to nrParams do:
	    actNr:= nr1;
	    for nr2 from nr1 to nrParams do:
	      counter3:= counter3+1;
	      actResult:= sumOverTime[counter3];

	      #
	      #actNr = nr1, workaround because of error: unevaluated array index
	      #
	      hessianNum[actNr,nr2]:=actResult;
	     #hessianNum[nr2,actNr]:=actResult;
	    end do:
	  end do:
        hessianNum:=Matrix(hessianNum, readonly=true, shape=symmetric);  
        return hessianNum;
      end proc:




      ##################################################################################################################
      # input: DDASPKproc -> module of type DDASPKSen
      #	       trajeSens -> module of type Curve, has to be created with function CreateODESolSen; representing the
      #			    simulated results
      #	       DDASPKsenRepeats -> Defines the number of integration repetitions for DDASPKSen (#applications of DoIntStep())
      #        outputFnctList-> list of equations, containing the response functions (g(x(t),p,u(t)))
      #	       resultCurve -> module of type Curve, has to be created with function CreateODESolSen; representing the
      #			      simulated results
      # output: Vector of diff(phi)/diff(pk) and LSQ difference between simulated results (trajeSens) and realResults
      # comment1: resultCurve is here used as a Curve object created by CreateODESolSen, ATTENTION, because we want to use real
      #		  data at some point. Then we have to adapt the error check for result Curve, or even again use a list of Vectors
      # comment2: to date only works with response functions that contain only variables (no parameters possible)
      # to do: remove DDASPKsenRepeats as input parameter, because it is not needed => correct all the worksheets
      #	to do1: here function listOfErrorsInOutputFunction needs a nother parameter (allParsList), that needs to be added
      ##################################################################################################################
      DeltaPhiAndLSQ:= proc(DDASPKproc::`module`,
        trajeSens::`module`,
        DDASKPsenRepeats::integer,
        outputFnctList::list(equation),
	realCurve::`module`
      )

      local deltaGMatrix, errList,data, sizeTrajeSens, actDAESys, nrVars, nrParams, nrFnct, initTime, endTimeOfSolution, listOfErrors,
        errMsg, simulatedResults, timePoints, actStartPosition, actEndPosition, startFlag, f, actItem, jakobianPars, jakobianVars, lsqResult,
	deltaPhiVector, differenceList, i, difference, k, actParam, sumPhiOverTime, sumPhiOverFunction, j, sumOverVars, actJakobianPars, actDifference,
	m, actState, actSensName, actSensValue, actJakobianVars, dgJdParam, VarsEqu, tmp, loopVars, subsList, varsList, senParamList, senParamNames,
	notSenParam, allParamList, realResults;	    
        ;

      #------------------------------------------------------------------------------------	
      #
      #check if arguments are correct
      #
      #------------------------------------------------------------------------------------	

      #
      #check if DDASPKproc is an instance of DDASPKSen
      #
      try
        varsList:= DDASPKproc:-GetVarNames();
	senParamList:= DDASPKproc:-GetSenParameters();
      catch "module does not export `%1`":
        ERROR("first parameter has to be an instance of DDASPKSen"):
      end try:

      
      #
      #check if trajeSens is a result of CreateODESolSen. For each variable x from varsList and for each parameter p from
      #paramList there must be one sensitivity name of the format dxdp as table index in trajeSens. Furthermore all
      #variables from varsList must be index in trajeSens.
      #
      senParamNames:= map(lhs,senParamList);      
      errList:= IsCurveFromCreateODESolSen(trajeSens, varsList, senParamNames);
      if  not
        errList=[]
      then
        ERROR(convert(errList, string));
      end:

      #
      #check if resultCurve is a result of CreateODESolSen. For each variable x from varsList and for each parameter p from
      #paramList there must be one sensitivity name of the format dxdp as table index in trajeSens. Furthermore all
      #variables from varsList must be index in trajeSens.
      #
      errList:= IsCurveFromCreateODESolSen(realCurve, varsList, senParamNames);
      if  not
        errList=[]
      then
        ERROR(convert(errList, string));
      end:

      #
      #define important variables
      #
      data:= trajeSens:-GetData();
      sizeTrajeSens:=trajeSens:-GetNumPoints();
      actDAESys := DDASPKproc:-GetSys();
      nrVars := nops(varsList);
      nrParams:= nops(senParamList);
      nrFnct := nops(outputFnctList);
      initTime:= data[time][1];

      #
      #check wether the outputFnctList has the right format (see also documentation of listOfErrorsInOutputFunctions)
      #
      listOfErrors := listOfErrorsInOutputFunctions(senParamNames,
        varsList,
	outputFnctList
      );

      #
      #if there has been an error, throw an exception with the corresponding message
      #
      if not
        listOfErrors=[]
      then
        errMsg:=convert(listOfErrors,string);
        error errMsg;
      end if:

      #
      #Create list of vectors of simulated results and of realResults
      #

      #create a list containing all parameters and their values	
      notSenParam:= DDASPKproc:-GetParameters();
      allParamList:= [op(senParamList), op(notSenParam)];
      simulatedResults:= CurveToListOfVectorsExt(trajeSens,
        outputFnctList,
	allParamList,
	varsList):

      realResults:= CurveToListOfVectorsExt(realCurve,
        outputFnctList,
	allParamList,
	varsList
      );	

      #
      #check if simulatedResults has the same length as the realResults
      #
      if not
	nops(simulatedResults)= nops(realResults)
      then
	ERROR("simulated and real Data have to contain the same number of timepoints => first and last input parameter are not compatible")
      end if:  

      #------------------------------------------------------------------------------------	
      #
      #Get trajectories and sensitivities and create Jakobian
      #
      #------------------------------------------------------------------------------------	

      #
      #Get the number of points in trajeSens
      #
      timePoints:=trajeSens:-GetNumPoints();

      #
      #create Jakobian regarding the Parameters and regarding the variables
      #
      jakobianPars := linalg[jacobian](map(rhs, outputFnctList),senParamNames);
      jakobianVars := linalg[jacobian](map(rhs, outputFnctList),varsList);


      #------------------------------------------------------------------------------------	
      #
      #Calculate the difference between real and simulated data and the LSQ-Value
      #
      #------------------------------------------------------------------------------------

      #
      #initialize the two return values
      #
      lsqResult:= 0:
      deltaPhiVector:= Vector(1..nrParams);

      #
      #collect for every timepoint the differences between real and simulated data in differenceList
      #
      differenceList:= Vector(1..timePoints);
      for i from 1 to timePoints do:

	#
	#calculate the difference between real and simulated data (all response functions are included in the vector difference)
	#
	difference:= simulatedResults[i]-realResults[i]:
	differenceList[i]:=difference;
	lsqResult := lsqResult + difference.difference:

      end do:  
      lsqResult:= 0.5*lsqResult:


      #------------------------------------------------------------------------------------	
      #
      #Calculate diff(phi,pl), see also diff(phi, parameter).pdf
      #
      #------------------------------------------------------------------------------------

      #
      #iterate over all parameter
      #
      for k from 1 to nrParams do:
	actParam:= senParamNames[k];	 

	sumPhiOverTime:=0;
	#
	#iterate over timePoints
	#
	for i from 1 to timePoints do:
	  sumPhiOverFunction:= 0;

	  #
	  #VarsEqu saves the Values for the dynamic Variables at time i
	  #
	  VarsEqu:=array(1..nrVars);
	  
	  #
	  #fill VarsEqu, containing equations: state=value, for substitution in the last loop (loop over state variables)
	  #
	  for tmp from 1 to nrVars do:
	    loopVars:= varsList[tmp]:
	    VarsEqu[tmp]:=loopVars=data[loopVars][i]:
	  end do:

	  #
	  #create subsList, for substitution in the last loop (loop over state variables) 
	  #
	  VarsEqu:=convert(VarsEqu, list):
	  subsList:=[op(VarsEqu),op(senParamList)]:

	  #
	  #iterate over response functions
	  #     
	  for j from 1 to nrFnct do:
	    sumOverVars := 0;
	    actJakobianPars := jakobianPars[j,k];
	    actDifference:= differenceList[i][j];

	    #
	    #Sum over statevariables, here subsList is needed
	    #
	    for m from 1 to nrVars do:
	      actState:= varsList[m];
	      actSensName := cat('d',actState,'d',actParam);	#create names ('dxdp') serving as indices for data table
	      actSensValue := data[actSensName][i];
	      actJakobianVars := jakobianVars[j,m];

	      #
	      #calculate dg/dp's for fixed timePoint and fixed response function
	      #
	      sumOverVars := sumOverVars +subs(subsList,actJakobianVars)*actSensValue;
	    end do:

	    #
	    #add single term to the previous calculated sumOverVars
	    #
	    dgJdParam := sumOverVars + subs(subsList,actJakobianPars);

	    #
	    #realize the first sum (over function) of diff(phi, dk)
	    #
	    sumPhiOverFunction:= sumPhiOverFunction + actDifference * dgJdParam
	  end do:

	  #
	  #realize the second sum (over time) of diff(phi, pk)
	  #
	  sumPhiOverTime:= sumPhiOverTime + sumPhiOverFunction;

	end do:

	#
	#store result each diff(phi, pk) in deltaPhiVector
	#
	deltaPhiVector[k]:= sumPhiOverTime:
      end do:

      return [deltaPhiVector, lsqResult];
      
      end proc:





      ##################################################################################################################
      # input: DDASKPproc -> Instance of the DDASPKSen, containing the DAESys of interest
      #	       DDASPKsenRepeats -> Defines the number of integration repetitions for DDASPKSen
      #        endTime -> right border of integration interval
      #        interval -> distance between points within the integration interval
      #        initTime ->startcondition for solution of the DAESys
      #        initVars -> values of the Variables at initTime
      #	       scaled -> true => skaling as in Yao 2003 formula 6 is used
      #	optional input: inputFct -> list containing tupels: [time, newInput]. Each tupel describes the timepoint, when
      #				    when the input should be changed, and the new value for the input
      # output: curve Object containing the solutions of the DAESys and the sensitivities of the variables
      # to do: catch errors (startTime<endTime, interval >endTime-startTime
      # problem: if endTime can not exactly be reached from startTime via the steplength interval, computation stops one
      #          step before endTime is reached.
      # to do: this version only can handle one variable input
      #	       improve the documentation of the warnings and the errors (for all procedures); use % functionality
      ##################################################################################################################
      CreateODESolSen :=  proc(DDASPKproc::`module`,
        DDASPKsenRepeats::integer,
        endTime::numeric,
	interval::numeric,
	initTime::numeric,
	initVars::list(numeric),
	scaled::boolean
	#optional argument inputFct::list([numeric,numeric])
      )

      local allParams, actDAESys, paramList, nrParams, varsList, nrVars, retHesse, JakobianPars, JakobianVars, iterEnd, trajectSens,
        i, variableName, j, paramName, k, T, X, TOUT, data, l, retVal, Y, m, imax, n, varsName, Sensi, o, p, actVal,
        counter, enum,curve, sensNames, item1, item2, otherData, startTimeInput, endTimeInput, tuples, inputFctCounter,
        inputParamName, inputFct, tmpTime, actInputFctTime, actInputFctValue, previousTime, w, errorList, errorMsg, extractPoint, nonSenParam,
	integrationTupel, initSensi, tmpFileName, fh, toWrite, r, s, tmpWrite, h, actVarsName, actParsName, actParsValue, actKey, actVarsValue,
	scalingFactor, senParsNameAndValues;

        actDAESys :=  DDASPKproc:-GetSys();
        paramList := map(lhs,actDAESys[SenPars]);
	allParams := [op(actDAESys[SenPars]),op(actDAESys[Parameters])];
        nrParams :=  nops(paramList);
        varsList := actDAESys[DynVars];
        nrVars := nops(varsList);
	nonSenParam:=actDAESys[Parameters];	


	#----------------------------------------------------------------------
        #
        #check if optional parameter inputFct is used, and has the right format
        #
        #----------------------------------------------------------------------
        if
	  (nargs = 8)
	then
	  inputFct :=  args[8];
	  errorList :=  listOfErrorsInInputList( actDAESys, initTime, inputFct);	  

	  if not
	    errorList=[]
	  then
	    errorMsg :=  convert(errorList, string);
	    error(errorMsg);
	  end if:

	  #
	  #initialize for later use for keeping track, when to change the input values according to the inputFct
	  #
	  inputParamName := lhs(actDAESys[Parameters][1]);
	  inputFctCounter := 1

	#
	#in this case we are not working with variable input
	#
	else
	  inputFct := [];
        end if;
        
	  
        #
        #check if initVars contains values for every dynamic variable in actDAESys
        #
        if
	  interval> endTime
	then
          error("third parameter has to be < than second parameter");
        end if;

        #
        #check if initVars contains values for every dynamic variable in actDAESys
        #
        if not
	  (nrVars=nops(initVars))
	then
           error("last parameter has to contain as many values as dynamic variables specified in the DAE System (first parameter)");
        end if:

        #
	#adopt the iteration number to the length of the distance between startTime and endTime regarding the interval lenght;
	#keep in mind, that we start at startTime (which has not to be an integer) and step forward with "interval" steps, thereby it is
	#not guaranteed to hit the endTime. iterEnd is important for setting the size of the array used to store the results obtained later. 
	#+ 1 because the initial state should be collected as well
	#
	if
	  (initTime = 0)
	then
	  iterEnd := floor(endTime/interval) + 1:
	else
	  iterEnd := floor(endTime/interval)- floor(initTime/interval) + 1;
	end if:

	#---------------------------------------------------------------------------------------------------------------------
	#
	#Initialize integration procedure; initialize  trajectSens (store the sensitivities and trajectories for each timepoint)
	#
	#---------------------------------------------------------------------------------------------------------------------

	#
	#initialize the Integration procedure
	#
	DDASPKproc:-SetVars(initVars):
	DDASPKproc:-SetInitialTime(initTime):
	DDASPKproc:-Init():
	
	#
	#initialize the time part of table trajectSens
	#
	trajectSens := table();
	enum :=  0;
	trajectSens[time] := array(1..iterEnd);

	#
	#initialize the trajectorie part of table trajectSens
	#
	for i from 1 to nrVars do:
	  variableName :=  varsList[i];
	  trajectSens[variableName] :=  array(1..iterEnd);
	 end do:

	#
	#Get the sensitivities for initialization
	#
	initSensi := DDASPKproc:-GetSensitivities();
	#
	#initialize Sensitivity part of table trajectSens
	#
	sensNames := map(lhs, initSensi);
	for item1 in sensNames do:
	  trajectSens[item1] :=  array(1...iterEnd);
	end do;

	#---------------------------------------------------------------------------------------------------------------------
	#
	#Create a debug file, with the relevant values per step
	#
	#---------------------------------------------------------------------------------------------------------------------

	#write ODEs into a file
        #
        # open temporary file
        #
        #tmpFileName:= "u:/reposit/maple/SysIdent/trunk/resultODENum.txt":
        #system(cat("rm -f ", tmpFileName));
        #fh:= open(tmpFileName, 'WRITE'):
        #fprintf(fh, "DEBUG data CreateODESolSen:= \n\n"):
	#toWrite:= "timepoint\tTOUT\t";

	#for r from 1 to nrVars do;
	#  toWrite:= cat(toWrite, varsList[r],"\t");
	#end do:

	#for s from 1 to nops(sensNames) do;
	#  toWrite:= cat(toWrite, sensNames[s],"\t ");
	#end do:
	
	#writeline(fh, toWrite);

	#---------------------------------------------------------------------------------------------------------------------
	#
	#collect trajectory and sensitivities for each timepoint with DDASPKSen, store in table trajectSens
	#
	#---------------------------------------------------------------------------------------------------------------------

	#
	#create trajectory and sensitivities between time startTime to endpoint with a distance between the points of stepsize;
	#
	for k from 1 to iterEnd do:

	  #
	  #initialize data store
	  #

	  #
	  #capture the intial state of the trajectory and the sensitivity
	  #
	  if
	    k=1
	  then
	    data  :=  array(1..1, 1..(nrVars+1));
	    #tmpWrite:= convert(initTime, string,"\t");
	    Y  :=  DDASPKproc:-GetY():
	    data[1,1]  := initTime ;
	    tmpTime := initTime;
       	  
	    for m from 2 to (nrVars+1) do:
	      data[1,m]  :=  Y[m-1];
	    end do:

	  #
	  #do integration for every timepoint after the initialTime
	  #
	  else	
	    #
	    #(k-1) because the initial state should be captured as well
	    #
	    TOUT  := (k-1)*interval+initTime;
	    tmpTime := TOUT - interval;
	    #tmpWrite:= cat(convert(evalf(tmpTime),string), "\t");
	    #tmpWrite:= cat(tmpWrite, convert(evalf(TOUT),string),"\t");
	    #----------------------------------------------------------------------
	    #
	    #handle variable input
	    #
	    #----------------------------------------------------------------------

	    #
	    #check wether we are working with variable input or not (in the latter case, inputFct=[]), in the first round of k
	    #don`t do anything, because the first input value has to be set already in the DDASPKproc instance; the incremented
	    #inputFctCounter must not be larger than the number of elements in inputFct
	    #
	    if not
	      inputFct=[]
	    then
	      #
	      #VariableInputHandler sets in DDASPKproc the new Parameter if necessary
	      #
	      inputFctCounter:= VariableInputHandler(DDASPKproc,
	        inputFct,
	        inputFctCounter,
	        tmpTime
	      );
	    end if:  

	    #------------------------------------------------------------------------
	    #
	    #------------------------------------------------------------------------

	    #
	    #do Integration step
	    #
	    integrationTupel:=DoDDASPKSenStep(DDASPKproc,
	      TOUT,
	      DDASPKsenRepeats
	    );

	    data:= integrationTupel[1];
	    imax:= integrationTupel[2];		    
	    
	  end if:  

	  #----------------------------------------------------------------------
	  #
	  #collect the results of the actual integration step of DDASPKSen
	  #
	  #----------------------------------------------------------------------

	  #
	  #again casecheck: k= 1 => no integration has been done so far, we just want to collect the initial values and the initial sensitivities
	  #
	  if
	    k=1
	  then
	    extractPoint := 1;
	  else
	    extractPoint := imax;
	  end if:
	  	  
	  #
	  #fill trajectSens with timepoints
	  #
	  trajectSens[time][k] :=  data[extractPoint,1];

	  #
	  #fill trajectSens with trajectory data
	  #
	  for n from 1 to nrVars do:
	    varsName := varsList[n];
	    trajectSens[varsName][k] :=  data[extractPoint,n+1];
	    #tmpWrite:= cat(tmpWrite, convert(data[extractPoint, n+1], string), "\t");
	  end do:

	  
	  #
	  #get sensitivities and fill trajectSens; sensNames contains the indices for the sensitivities in table trajectSens
	  #
	  Sensi := DDASPKproc:-GetSensitivities();
	  counter :=  1;
	  for item2 in sensNames do:
            trajectSens[item2][k] :=  rhs(Sensi[counter]);
	    #tmpWrite:= cat(tmpWrite, convert(rhs(Sensi[counter]), string), "\t");
	    counter :=  counter +1;
	  end do;
	  #writeline(fh, tmpWrite);

	end do:

	#
	#check if a scaled is demanded
	#
	if
	  scaled
	then	
	  #
	  #create systematically all sensitivity names and scale the corresponding values
	  #
	  senParsNameAndValues:=actDAESys[SenPars];
	  for h from 1 to iterEnd do:
	    for i from 1 to nops(varsList) do:
	      actVarsName:= varsList[i];
	      for j from 1 to nops(senParsNameAndValues) do:
	        actParsName:=lhs(senParsNameAndValues[j]);
	        actParsValue:=rhs(senParsNameAndValues[j]);
	        actKey:= cat(d,actVarsName,d,actParsName);
	        actVarsValue:= trajectSens[actVarsName][h];
	        if
	          actVarsValue=0
	        then
	          error("Scaling is not possible, because the actVars: %1, is zero => division by zero",actVarsName);
	        else
	          scalingFactor:= actParsValue/actVarsValue;
	        end if:
	        trajectSens[actKey][h]:= trajectSens[actKey][h]* scalingFactor;
	      end do:
	    end do:
	  end do:  
	end if:


	#
	#reset nonSen Parameter in DDASPKproc to original value
	#
	DDASPKproc:-SetParameters(nonSenParam);

	#----------------------------------------------------------------------
	#
	#create Curve Object that contains the timepoints, the trajectories and
	#the sensitivities
	#
	#----------------------------------------------------------------------
	otherData := ['NumPoints'=iterEnd, Parameters= allParams, SpecialVarNames=varsList];
	curve := ModelPack:-CreateCurve(trajectSens,otherData);
	return curve;

      end proc:

      ##################################################################################################################
      # input:		DDASPKproc => instance of DDASPKSen
      #			inputFctList => list containing tupel; first element defines the time, when to change the input
      #			parameter and the second element defines the new Parameter value
      #			fctCounter => integer that keeps track, at which element of inputFctList, we start
      #			actTime => specifies the time DDASPKSen has stopped
      #	sideeffects:	if actTime is >= as the time in inputFctList the fctCounter points at, than update the new Value of
      #			the Parameter in DDASPKproc.
      # output:		return the actualized fctCounter
      ##################################################################################################################
      VariableInputHandler:= proc(DDASPKproc::`module`,
        inputFct::list([numeric,numeric]),
	fctCounter::numeric,
	actTime::numeric
	)
	local actDAESys, inputFctCounter,actInputFctValue, actInputFctTime, inputParamName;
      	#----------------------------------------------------------------------
	#
	#handle variable input
	#
	#----------------------------------------------------------------------

	inputFctCounter:= fctCounter;

	#
	#check wether we are working with variable input or not (in the latter case, inputFct=[]), in the first round of k
	#don`t do anything, because the first input value has to be set already in the DDASPKproc instance; the incremented
	#inputFctCounter must not be larger than the number of elements in inputFct
	#
	actDAESys:= DDASPKproc:-GetSys();    
	inputParamName := lhs(actDAESys[Parameters][1]);
	#
	#special case if there is only one value in inputFct
	#	 
	if
	  nops(inputFct)=1
	then  
	  if
	    inputFctCounter <= nops(inputFct) and actTime >= inputFct[1][1]
	  then
	    actInputFctValue := inputFct[1][2];
	    DDASPKproc:-SetParameters([inputParamName=actInputFctValue]);
	    DDASPKproc:-Init();
	    inputFctCounter:= inputFctCounter +1;
	  end if

	#
	#inputFct is not empty and has more than one entry
	#
	elif not
	  inputFct = []
	then

	  #
	  #if there are still elements left in inputFct
	  #
	  if
	    inputFctCounter < nops(inputFct)
	  then
	    #actInputFctTime:= inputFct[inputFctCounter][1];

	    #
	    #if tmpTime is > inputFct[inputFctCounter][1], then we have to look at the next tuple of inputFct and check, wether its first value is
	    #equal or larger than tmpTime
	    #
	    if
	      actTime >= inputFct[inputFctCounter][1]
	    then

	      #
	      #check the inputFct list, if one of the next time Values in inputFct list is larger or equal to actTime
	      #		    
	      while(inputFctCounter < nops(inputFct) and actTime > inputFct[inputFctCounter][1]) do:

		# 
		#if the next inputFctTimePoint is <= actTime do the incrementation step
		#
		if 
		  inputFct[inputFctCounter +1][1] <= actTime 
		then
  		  inputFctCounter := inputFctCounter + 1;
		  actInputFctTime:= inputFct[inputFctCounter][1];

		#
		#the next inputFctTimePoint is > => do not change the actual input Parameter
		#
		else
		  break
		end if:  
	      end do:

	      #
	      #the appropiate inputFctValues has been discoverd, and therefore we can set the new Parametervalue
	      #
	      actInputFctValue := inputFct[inputFctCounter][2];
	      DDASPKproc:-SetParameters([inputParamName=actInputFctValue]);
	      DDASPKproc:-Init();
	      
	    end if:
	  end if:
	end if;
	return inputFctCounter;
      end proc:

      ##################################################################################################################
      # input: DDASPKproc => an instance of DDASPKsen
      #	       DDASPKsenRepeats => integer number of integration steps between the step of this procedure
      #	       endTime => endTime of integration
      # sideeffect: lets DDASPKproc fullfill integration until time endTime
      # output: tupel
      #		1. element: an 2d array (1..DDASPKsenRepeats+1,1..#Variables+1), storing all Integration values for
      #		each variable for each integration step between act Time of DDASPKproc and endTime
      #		2. element: Counter of the last succesful iteration
      #	documentation of DDASPKSen Errors: U:\Reposit\Maple\DDASPKSen\trunk\ext_routines\shared_obj\ddaspk.f 	
      ##################################################################################################################
      DoDDASPKSenStep := proc(DDASPKproc::`module`,
	endTime::numeric,
        DDASPKsenRepeats::numeric)

        local actDAESys, nrVars, retVal, Y, T, data,l, m, imax, returnTupel, actValues;
        
	#
	#set the time, when integration should end
	#
	DDASPKproc:-SetEndTime(endTime):
	
	#
	#define important variables
	#
	actDAESys:=DDASPKproc:-GetSys();
	nrVars:= nops(actDAESys[DynVars]);
	data  :=  array(1..DDASPKsenRepeats+1, 1..(nrVars+1));

	
	#----------------------------------------------------------------------
	#
	#do integration step for DDASKPsenRepeats
	#
	#----------------------------------------------------------------------
	for l from 1 by 1 to DDASPKsenRepeats do
	  retVal  :=  DDASPKproc:-DoIntStep():
	  Y  :=  DDASPKproc:-GetY():
	  T  :=  DDASPKproc:-GetT():
	  data[l,1]  :=  T;

	  #
	  #DoIntStep has several return values: 1 means, TOUT is not reached, so try again
	  #
	  if
	    (retVal = 1)
	  then
	    next;

	  #
	  #retVal -33 means, that there occured an unrecoverable problem within DDASPKSen => resolve this problem by reinitializing
	  #
	  elif
	    (retVal = -33)
	  then
	    DDASPKproc:-Init();
	    #
	    #print warning because of the unrecoverable problem
	    #
	    #WARNING("DDASPKproc had to be Reinitialized. Error -33 occured");

	  #
	  #in this two cases integration was succesfull (2 => integration exactly reached integration end, 2 => integration passed the integration end)
	  #
	  elif
	    retVal in {2, 3}
	  then  
	    break;

	  #
	  #during integration DDASPKSen produced an error. For details see: U:\Reposit\Maple\DDASPKSen\trunk\ext_routines\shared_obj\ddaspk.f
	  #
	  else  
	    ERROR("During integration DDASPKSen produced the error ID %1" ,retVal);
	  end if;
	end do:

	#
	#when previous loop is fully iterated without succsess => l = DDASPKsenRepeats +1.	    
	#
	if
	  l =DDASPKsenRepeats + 1
	then
	  actValues:= [seq(Y[i], i=1..nrVars)];
	  actValues:= convert(actValues, string);
	  print("Time: ", T);
	  print("\nVariable Values: ", actValues); 
	  ERROR(cat("DDASPKproc has not reached integration end, you have to choose a higher iteration (second Parameter) \n",
	    actValues
	  ));
	end if:

	for m from 2 to (nrVars+1) do:
	  data[l,m]  :=  Y[m-1];
	end do:

	#
	#keep track of the last succesful iteration where DoIntStep was true
	#
	imax :=  l;

	return [data, imax];

      end proc:	  


      ##################################################################################################################
      # input: DDASKPproc -> Instance of the DDASPKSen, containing the DAESys of interest
      #	       DDASPKsenRepeats -> Defines the number of integration repetitions for DDASPKSen      
      #        endTime -> right border of integration interval
      #        interval -> distance between points within the integration interval
      #        initTime ->startcondition for solution of the DAESys
      #        initVars -> values of the Variables at initTime
      # output:	returns a tupel:	
      #		1. element = curve Object containing the analytival solutions of the DAESys and the sensitivities of the variables
      #		2. element =list with the names of the vars and the sensitivities => thereby simplifies further acces to the curve
      #			    that is principally organised as table.
      # to do: catch errors (startTime<endTime, interval >endTime-startTime
      # problem: if endTime can not exactly be reached from startTime via the steplength interval, computation stops one
      #          step before endTime is reached.
      # to do: this version only can handle one variable input
      ##################################################################################################################
      CreateODESolSenAnal :=  proc(DDASPKproc::`module`,
        DDASPKsenRepeats::integer,
        endTime::numeric,
	interval::numeric,
	initTime::numeric,
	initVars::list({numeric, name})
	#optional argument inputFct::list([numeric,numeric])
      )

      local paramList ,nrParams ,varsList ,nrVars ,nrFnct ,dynVars ,nrVar ,ODEsys ,nrODEs ,varsToFct ,varsToInitFct ,initEqu,
        ODErhs ,ODEFromDAESys ,item ,sol ,hessianAnalytic ,Sys ,fctList ,jakobianPars ,i ,j ,firstParam ,secondParam ,sumOverFunct,
        m, sumOverTime, k, actTime, actJakobianI, actJakobianJ, actJakobianValueI, actJakobianValueJ, actDAESys, trajeSens, data, timePoints,
	actStartPosition, f, actItem, errorMsg, inputFct, errorList, inputParamName, inputFctCounter, actInputFctTime, actInputFctValue, substIntoJakobian,
	nonSenParam, enum, tmpTrajeSens, trajeSen, variableName, Sensi, sensNames, item1, n, actJakobian,s, tmpSys, actTraje, otherData, curve, t0,
	nextInitTime, oneTimeFlag, substInitEqu, initNameList, dynVarsSubsList, jakobianParsMatrix, jakobianVars, jakobianVarsMatrix, dODE, dNameList,
	dNameMatrix, actdNameRow, actJakobianVarsColumn, firstSummand, secondSummand, actJakobDyn, jacobianInitdotD, nrRows, nrColumns,
	jacobianInitdotDList, dotD, dotDNames, dotDSys, varsToSubsInDotDSys, initSenNameList, initEquSen, completeODEs, completeIC, completeSys,
	subsInitDList, actSen, nameList, tmpFileName, fh, toWrite, r, actParam, actSensName;

        #
        #initiate important Variables
        #
	actDAESys := DDASPKproc:-GetSys();
	paramList := map(lhs,actDAESys[SenPars]);
	nrParams :=  nops(paramList);
	varsList := actDAESys[DynVars];
	nrVars := nops(varsList);
	nrFnct := nops(outputFnctList);
	nonSenParam:=actDAESys[Parameters];


	#
	#if there are no Parameters an empty list will be returned
	#
	nonSenParam:=actDAESys[Parameters];

        #-------------------------------------------------------------------------------------------
	#
	#check if optional parameter is used, and has the right format, check additional conditions
	#
	#-------------------------------------------------------------------------------------------
	if
	  (nargs = 7)
	then
	  inputFct :=  args[7];
	  errorList :=  listOfErrorsInInputList( actDAESys, initTime, inputFct);
	  if not
	    errorList=[]
	  then
	    errorMsg :=  convert(errorList, string);
	    error(errorMsg);
	  end if:

	  #
	  #initialize for later use in keeping track, when to change the input values according to the inputFctList
	  #
	  inputParamName := lhs(actDAESys[Parameters][1]);
	  inputFctCounter := 1
	else
	  inputFct := [];
	end if: 


	#-------------------------------------------------------------------------------------------
	#
	#Calculate the # of time points; state ODE-System for the trajectory
	#
	#-------------------------------------------------------------------------------------------

	#
	#adopt the iteration number to the length of the distance between startTime and endTime regarding the interval lenght;
	#keep in mind, that we start at startTime (which has not to be an integer) and step forward with "interval" steps, thereby it is
	#not guaranteed to hit the endTime. iterEnd is important for setting the size of the array used to store the results obtained later. 
	#+ 1 because the initial state should be collected as well
	#
	if
	  (initTime = 0)
	then
	  timePoints := floor(endTime/interval) + 1:
	else
	  timePoints := floor(endTime/interval)- floor(initTime/interval) + 1;
	end if:

	#
	#state the ODEsys from the DAESys
	#
	ODEFromDAESys:= StateODESysForDsolve(actDAESys[ODEs], actDAESys[DynVars]);
	

	dynVars :=  actDAESys[DynVars];
	ODEsys := actDAESys[ODEs];
	nrODEs := nops(ODEsys);

	#
	#list of names for initial condition: for each variable xi there is an initxi
	#
	initNameList:= [seq(
	  cat(init,dynVars[i]),
	  i=1..nrVars
	)];


	#---------------------------------------------------------------------------------------------------------------------
	#
	#Calculate Sensitivity Equations as proposed in Schittkowski (2002) Numerical Data Fitting in Dynamical Systems (pp 44):
	#one needs to calculate the Jakobian regarding the parameters and the dynamic variables and state an ODEsys
	# diff(d(t), t)= d(t)*JakobianVars() + JakobianParam
	#
	#---------------------------------------------------------------------------------------------------------------------

	#
	#calculate the InitialValues for dotD, see page 45 Schittkowski and flatten it
	#

	jacobianInitdotD:= linalg[jacobian](initVars,paramList);
	jacobianInitdotD:= convert(jacobianInitdotD, Matrix);
	jacobianInitdotD:= LinearAlgebra[Transpose](jacobianInitdotD);
	nrRows:= op(1,jacobianInitdotD)[1];
	nrColumns:= op(1,jacobianInitdotD)[2];
	jacobianInitdotDList:= [seq(
	  op(convert(jacobianInitdotD[i, 1..nrColumns],list)),
	  i= 1..nrRows
	)];
	
	dotD := CreateDotD(actDAESys);

	#
	#state the ODEsys from dotD 
	#
	dotDNames:= dotD[2];
	dotDSys:= StateODESysForDsolve(dotD[1], dotDNames);

	#
	#replace in dotDSys the occurence of dynamic Variables xi from the general ODEs against xi(t)
	#
	varsToSubsInDotDSys:= TransformDynamicVars(dynVars);	
	dotDSys:= subs(varsToSubsInDotDSys, dotDSys);

	#
	#initSenNameList contains for each name dij the corresponding initdij
	#
	initSenNameList:= [seq(
	  cat(init,dotDNames[i]),
	  i=1..nops(dotDNames)
	)];

	#---------------------------------------------------------------------------------------------------------------------
	#
	#Put together the ODE for the Sensitivities and the ODE for the system Variables
	#
	#---------------------------------------------------------------------------------------------------------------------
	
	#
	#state the general initial conditions for the sensitivityODE and the original ODE
	#
	initEquSen:= StateInitCondForDsolve(dotDNames, initSenNameList  ,t0);
	initEqu:= StateInitCondForDsolve(varsList, initNameList  ,t0);	

	#
	#Collect the ODEs and the initEquations in a set, that is solved later on with the dsolve-command
	#
	completeODEs:=op(ODEFromDAESys), op(dotDSys);
	completeIC:= op(initEqu), op(initEquSen);
	completeSys:= {completeODEs, completeIC};

	#
	#solve the completeODEs
	#
	sol := dsolve(completeSys);

	#
	#create a List: for each variable  xi (dij) => xi=xi(t) (dij=dij(t))
	#
	dynVarsSubsList:= TransformDynamicVars([op(varsList), op(dotDNames)]); 

	#
	#
	#
	Sys :=  subs(
	  sol,
	  dynVarsSubsList
	);


	#---------------------------------------------------------------------------------------------------------------------
	#
	#initialize the table trajeSens to store all trajectorial and sensitivitie values
	#
	#---------------------------------------------------------------------------------------------------------------------
	trajeSen := table();
	trajeSen[time] := array(1..timePoints);
	sensNames:=[];
	#
	#initialize the trajectorie and the sensitivity table
	#
	for i from 1 to nrVars do:
	  variableName :=  varsList[i];
	  trajeSen[variableName] :=  array(1..timePoints);

	  for j from 1 to nrParams do:
	    actParam:=paramList[j];
	    actSensName := cat('d',variableName,'d',actParam);
	    sensNames:=[op(sensNames), actSensName];
	    trajeSen[actSensName]:= array(1..timePoints);
	  end do:
	  
	end do:

	#---------------------------------------------------------------------------------------------------------------------
	#
	#calculate trajectory and sensitivities by substituting the corresponding values into the solution of the ODE (here the
	#the variable Sys)
	#
	#---------------------------------------------------------------------------------------------------------------------
	
	#
	#nextInitTime is needed for keeping track of the time to substitute later
	#
	nextInitTime:=initTime;

	#
	#boolean flag for the case, that we have only one inputFct entry
	#
        oneTimeFlag:= false;

	for k from 1 to timePoints do:
	  actTime:= evalf((k-1)*interval + initTime);
	  trajeSen[time][k]:= actTime;
	  #---------------------------------------------------------------------------------------------------------------------
	  #
	  #handle variable Input, store actual nonSen Parameter Value, for later substitution
	  #
	  #---------------------------------------------------------------------------------------------------------------------

	  #
	  #if we are in the first iteration, than don't apply any input, but keep the konfiguration of DDASPKSen for
	  #the non-Sensitivity Parameter (nonSenParam)
	  #
	  if
	      k=1
	  then	
	    substIntoJakobian:=nonSenParam;

	    #
	    #get the initial Values for the sensitivities, substitute them for the initdij
	    #
	    subsInitDList:= [seq(
	      initSenNameList[i] = jacobianInitdotDList[i],
	      i = 1 .. nops(jacobianInitdotDList)
	    )];

	    #
	    #list containing the initialCondition to substitute into the jakobian later
	    #
	    substInitEqu:=[seq(
	      eval(rhs(initEqu[i]))=initVars[i],
	      i=1..nrVars
	    )]; 
	 
	  #
	  #only one input spezified in inputFct
	  #
	  elif
	    nops(inputFct)=1
	  then
	    
	    if
	      actTime > inputFct[1][1]
	    then
	      
	      actInputFctValue:= inputFct[1][2];
	      substIntoJakobian:=[inputParamName = actInputFctValue];

	      if
	        oneTimeFlag = false
	      then
	        oneTimeFlag:=true;

		#
		#list containing the new initial Condition, obtained from the Trajectories of the integration step before.
	        #This should be substituted later into the Jakobian, and into the System
	        #
	        substInitEqu:=[seq(
		  rhs(initEqu[i])=trajeSen[lhs(Sys[i])][k-1],
		  i=1..nrVars
	        )];

		#
		#list with elements initdij=numeric containing the new init Values for the next integration step of the sensitivities;
		#obtained from the sensitivities of one step before.
		#
		subsInitDList:= [seq(
		  initSenNameList[i] = trajeSen[sensNames[i]][k-1],
		  i = 1 .. nops(initSenNameList)
		)];
	
	      end if;	

	      #
	      # if we are in this case, we have encountered an input change => remember this iteration
	      #
	      nextInitTime:=inputFct[1][1];

	    else
	      substIntoJakobian:=nonSenParam;
	    
	    end if

	  #
	  #inputFct contains more than one entry
	  #
  	  elif not
	    inputFct = []
          then
	    #
	    #if actTime is > actInputTime, then we have to look at the next tuple of inputFct and check, wether its first value is
	    #>= than tmpTime
	    #
	    if
	      actTime>inputFct[inputFctCounter][1]
	    then
	      actInputFctTime:= inputFct[inputFctCounter][1];
	      #
	      #check the inputFct list, if one of the next time Values in inputFct list is larger or equal to actTime
	      #
   	      while(inputFctCounter < nops(inputFct) and actTime > actInputFctTime) do:#
	          
	        # 
	        #if the next inputFctTimePoint is <= actTime do the incrementation step
	        #
	        if 
		  inputFct[inputFctCounter +1][1] < actTime 
	        then
		  inputFctCounter := inputFctCounter + 1;
		  actInputFctTime:= inputFct[inputFctCounter][1];#
	          substInitEqu:=[seq(
		    rhs(initEqu[i])=trajeSen[lhs(Sys[i])][k-1],
		    i=1..nrVars
	          )];

		  #
		  #list with elements initdij=numeric containing the new init Values for the next integration step of the sensitivities;
		  #obtained from the sensitivities of one step before.
		  #
		  subsInitDList:= [seq(
		    initSenNameList[i] = trajeSen[sensNames[i]][k-1],
		    i = 1 .. nops(initSenNameList)
		  )];

		  
		  #
		  #the next inputFctTimePoint is > => do not change the actual input Parameter
		  #
	        else

		  if
		    oneTimeFlag=false
		  then
	            substInitEqu:=[seq(
		      rhs(initEqu[i])=trajeSen[lhs(Sys[i])][k-1],
		      i=1..nrVars
	            )];
		    #
		    #list with elements initdij=numeric containing the new init Values for the next integration step of the sensitivities;
		    #obtained from the sensitivities of one step before.
		    #
		    subsInitDList:= [seq(
		      initSenNameList[i] = trajeSen[sensNames[i]][k-1],
		      i = 1 .. nops(initSenNameList)
		    )];

		  end if;
		  break
	        end if:  
	      end do:
	      oneTimeFlag:=true;
    
	      #
	      #the appropiate inputFctValues has been discoverd, and therefore we can set the new Parametervalue
	      #Additionaly we set new initial conditions as the k-1 actTraje value
	      #
	      
	      actInputFctValue := inputFct[inputFctCounter][2];
	      substIntoJakobian:= [inputParamName=actInputFctValue];
	      nextInitTime:=inputFct[inputFctCounter][1];

	    end if:
       
	  # 
	  # if we don't have an inputFct, set substIntoJakobian to nonSenParam
	  # 
	  else
	    substIntoJakobian:=nonSenParam;  
	  end if:

	  #---------------------------------------------------------------------------------------------------
	  #
	  #Calculate the trajectories and store in table trajeSen;
	  #the first nrVars Equations of Sys describe the trajectories of the system
	  #
	  #---------------------------------------------------------------------------------------------------
	  for s from 1 to nrVars do:
            tmpSys:=rhs(Sys[s]);
	    actTraje:= subs( [op(actDAESys[SenPars]),op(substIntoJakobian),op(substInitEqu), t=actTime, t0=nextInitTime],tmpSys);
	    trajeSen[lhs(Sys[s])][k]:= evalf(actTraje);
	    toWrite:= cat(toWrite, convert(evalf(actTraje), string),"\t");
	  end do:


	  #---------------------------------------------------------------------------------------------------------------------
	  #
	  #calculate sensitivities and store in table trajeSen, Sys[k] k>= nrVars + 1 contains the equation for the sensitivities
 	  #
	  #---------------------------------------------------------------------------------------------------------------------
	  for n from nrVars+1 to nops(Sys) do:
            tmpSys:=rhs(Sys[n]);
	    actSen:= subs( [op(subsInitDList), op(actDAESys[SenPars]),op(substIntoJakobian),op(substInitEqu), t=actTime, t0=nextInitTime],tmpSys);
	    trajeSen[sensNames[n-nrVars]][k]:= evalf(actSen);
	    toWrite:= cat(toWrite, convert(evalf(actSen), string),"\t");
	  end do:

	  writeline(fh, toWrite);  
       	end do:  

	#
	#close the debug file
	#
	#close(fh):

	#----------------------------------------------------------------------
	#
	#create Curve Object that contains the timepoints, the trajectories and
	#the sensitivities
	#
	#----------------------------------------------------------------------
	otherData := ['NumPoints'=timePoints, Parameters=[]];
	curve := ModelPack:-CreateCurve(trajeSen,otherData);
	nameList:= [op(varsList), op(sensNames)];
	return [curve, nameList];   

      end proc:	


      ##################################################################################################################
      # input: dynVars-> list of variable names 
      #	       initValues -> list that spezifies the initial condition, has to contain as many elements as variables in
      #			     dynVars
      #	       initTime -> name or value of the initial Time
      #	       
      # output: A list, that contains the initial conditions for the variable names in dynVars =>
      #		for dynamic Variable xi the following equation is created => xi(initTime) = initValue[i]
      ##################################################################################################################
      StateInitCondForDsolve := proc(dynVars::list(name),
        initValues::list({numeric, name}),
	initTime::{numeric, name}
	)

	local nrVars, varsToInitFct, initEqu ;

	#
	#get important values
	#
	nrVars := nops(dynVars); 

	#
	#check if second argument contains as many values as aDAESys contains dynamic Variables
	#
	if not
	  nops(initValues)=nrVars
	then
	  error("the second argument has to contain as many values as the first argument (DAESys) defines dynamic Variables");
	end if:

	#
	#create for dynamic variable xi the name xi(initTime)
	#
	varsToInitFct := [seq(
	  dynVars[i](initTime),
	  i=1..nrVars
	)];

	#
	#create for dynamic variables the initial Equations: xi(t0) = initxi
	#
	initEqu := [seq(
	  varsToInitFct[i]=initValues[i],	
	  i=1..nrVars
	)];

	return initEqu;


      end proc:	




      ##################################################################################################################
      # input: ODEList-> List of ODEs
      #	       dynVars -> a list containing the names of the dynamic variables the ODEs
      #	       
      # output: A Set containing the ODEs that can be used as input for maples dsolve command
      #        {ode1, ...oden} odei:= diff(xi(t), t) = ....
      #
      # tip + caution: best use this function with first Pameter= aDAESys[ODEs] and second Parameter = aDAESys[DynVars],
      #		       because there is no consitency check done within this procedure, i.e. wrong dynVars will not be
      #		       detected
      ##################################################################################################################
      StateODESysForDsolve :=  proc(ODEList::list(equation),
        dynVars::list(name)
        )

        local result,  nrVars, ODEsys, nrODEs, varsToFct, ODEsysSubs, ODErhs, ODEFromDAESys;

	#
	#get important values
	#
	nrVars := nops(dynVars); 
	ODEsys := ODEList;
	nrODEs := nops(ODEsys);

	#
	#check if there are as many dynamic Variables as differential equations
	#
	if not
	  nrVars=nrODEs  
	then
	  error("there have to be as many dynamic Variables (secondParameter) as differential equations (first Parameter)");
	end if:
	

	#
	#create for dynamic variable xi the name xi(t)
	#
	varsToFct := [seq(
	  dynVars[i](t),
	  i=1..nrVars
	)];

	#
	#replace dynamic variable xi with xi(t) in the original ODE from aDAESys 
	#
	ODEsysSubs := subs(
	  seq(
	    dynVars[i]=varsToFct[i],
	    i=1..nrVars
	    ),
	  ODEsys
	);
	
	ODErhs := map(rhs, ODEsysSubs);

	#
	#state every ODE in the form: diff(xi(t),t)= ....
	#
	ODEFromDAESys :=  [seq(
	  diff(varsToFct[i],t)=ODErhs[i],
	  i=1..nrODEs
	)]:

	result:= ODEFromDAESys;
	return result;

      end proc:


      ##################################################################################################################
      # input: dynVars-> a list of variable names 
      # output: A List with following entries:
      #		for each entry xi in dynVars this equation is created:  xi=xi(t)
      ##################################################################################################################
      TransformDynamicVars :=  proc(dynVars::list(name)
        )

        local result, nrVars, ODEsys, nrODEs;

	#
	#get number of variables in dynVars
	#
	nrVars := nops(dynVars); 

	#
	#create for variable  xi in dynVars the equation : xi = xi(t)
	#
	result := [seq(
	  dynVars[i]=dynVars[i](t),
	  i=1..nrVars
	)];
	return result;

      end proc:



      ##################################################################################################################
      # input: aDAESys => DAESys of interest
      #		
      # output: Returns a tupel.
      #		First entry contains a List of ODEs as described in Schittkowski(2002), Numerical Data
      #		Fitting in Dynamical Systems (2.59). They describe the derivative of the sensitivities. The ODEs are in
      #		such a format, that dsolve can recognize them.
      #
      #		Second entry contains a list of the variables of the ODEs, such that dsolve can use them
      #		i.e. [d11(t)...dsn(t)] with s=#Parameters n=#Variables  
      ##################################################################################################################
      CreateDotD :=  proc(aDAESys::DAESys
        )

        local ODEsys, senParamNames, varNames, nrVars, nrParams, dDot, jacobianPars, jacobianVars, jacobianVarsTrans, jacobianParsTrans,
	  dNameList, dNameMatrix, actdNameRow, actJacobianVarsColumn, n, s,i, j , actDiffName, ODEList, firstSummand, secondSummand, DVarsList;

	#
	#check wether SenPars are already defined
	#
	if
	  aDAESys[SenPars] = []
	then
	  error("There are non Sensitivity Parameters (SenPars) defined in aDAESys");
	end if:	  
	  
	#
	#Introduce important variables
	#
	ODEsys:=map(rhs,aDAESys[ODEs]);
	senParamNames:=map(lhs,aDAESys[SenPars]);
	varNames:= aDAESys[DynVars];
	nrVars:=nops(varNames);
	nrParams:= nops(senParamNames);
	dDot:= Matrix(1..nrParams, 1..nrVars);


	#
	#create Jakobian for ODESys spezified in aDAESys regarding parameters and variables
	#
	jacobianPars:= linalg[jacobian](ODEsys,senParamNames);
	jacobianVars:= linalg[jacobian](ODEsys,varNames);

	#
	#convert to matrix and transpose, because in Schittkowski (2002) Numerical Data Fitting in Dynamical Systems p 44
	#the jakobi is defined different, than in maple
	#
	jacobianPars:= convert(jacobianPars, Matrix);
	jacobianVars:= convert(jacobianVars, Matrix);

	jacobianParsTrans:= LinearAlgebra[Transpose](jacobianPars);
	jacobianVarsTrans:= LinearAlgebra[Transpose](jacobianVars);

	#
	#create dNameMatrix: [d11...d1n]....[ds1 ...dsn]  n=#Variables  s=#Parameters
	#

	dNameList:= [ seq(
		        [seq(
			  cat(d,s,n),
			  n = 1..nrVars
			)],
			s=1..nrParams
		    )];
        dNameMatrix:= convert(dNameList, Matrix);


	#------------------------------------------------------------------
	#
	#fill Matrix dotD. Formula as in Schittkowski(2002) page 44 (2.59)
	#
	#------------------------------------------------------------------

	for s from 1 to nrParams do:
	  actdNameRow:= dNameMatrix[s, 1..nrVars];  
	  for n from 1 to nrVars do:
	    actJacobianVarsColumn:= jacobianVarsTrans[1..nrVars, n];
	    firstSummand:=actdNameRow.actJacobianVarsColumn;
	    secondSummand:=jacobianParsTrans[s,n];
	    dDot[s,n]:=firstSummand + secondSummand;
	  end do:
	end do:

	#------------------------------------------------------------------
	#
	#Create a DAESys of the dDot matrix
	#
	#------------------------------------------------------------------

	#
	#Create ODEs from dDot Matrix and store in ODEList
	#
	ODEList:=[];
	for i from 1 to nrParams do:
	  for j from 1 to nrVars do:
	    actDiffName:= cat(dNameMatrix[i,j],`'`);
	    ODEList:= [op(ODEList), actDiffName = dDot[i,j]] 
	  end do:
	end do:  

	DVarsList:=[seq(
	  op(dNameList[i]),
	  i= 1..nops(dNameList)
	  )];

	return [ODEList, DVarsList] ;
	
      end proc:


      ##################################################################################################################
      # input: DDASPKproc -> Instance of DDASPKSen
      #	       DDASPKsenRepeats -> Defines the number of integration repetitions for DDASPKSen
      #        startTime -> left border of integration interval
      #        endTime -> right border of integration interval
      #        interval -> distance between points within the integration interval
      #        initTime ->startcondition for solution of the DAESys
      #        initVars -> values of the Variables at initTime
      #        outputFnctList-> list of equations, containing the response functions
      #	       
      # output: 2D array containing the Hessian Matrix of Phi solved analytical not numerical
      # todo: check correct format of the outputfunction (implement small function)
      # todo: change function corresponding to CreateHessian: as Parameter is a curveObject used;
      #	      not absolutely necessary, because this is only a control function
      ##################################################################################################################
      CreateAnalyticHessian :=  proc(DDASPKproc::`module`,
        DDASPKsenRepeat::integer,
        startTime::numeric,
	endTime::numeric,
	interval::numeric,
	initTime::numeric,
	initVars::list(numeric),
	outputFnctList::list(equation)
	#optional parameter inputFct::list([numeric,numeric])
      )

      local paramList ,nrParams ,varsList ,nrVars ,nrFnct ,dynVars ,nrVar ,ODEsys ,nrODEs ,varsToFct ,varsToInitFct ,initEqu,
        ODErhs ,ODEFromDAESys ,item ,sol ,hessianAnalytic ,Sys ,fctList, actDAESys, nonSenParam, inputFct, errorList, errorMsg,
	inputParamName, inputFctCounter, trajeSen, trajeSenCurve, trajeSenNames, data, timePoints, actStartPosition, f, actItem,
	jakobianPars, jakobianVars, l, firstParam, k, secondParam, sumOverTime, i, sumOverFunct, actTime, actVarsValues, subsList,
	j, sumOverVarsL, sumOverVarsK, actJakobianParsL, actJakobianParsK, m, actState, actSensNameL, actSensNameK, actSensValueL,
	actSensValueK, actJakobianVars, dgJdParamL, dgJdParamK ;


	#
        #initiate important Variables
        #
	actDAESys := DDASPKproc:-GetSys();
	paramList := map(lhs,actDAESys[SenPars]);
	nrParams :=  nops(paramList);
	varsList := actDAESys[DynVars];
	nrVars := nops(varsList);
	nrFnct := nops(outputFnctList);
	nonSenParam:=actDAESys[Parameters];

        #-------------------------------------------------------------------------------------------
	#
	#check if optional parameter is used, and has the right format, check additional conditions
	#
	#-------------------------------------------------------------------------------------------
	if
	  (nargs = 9)
	then
	  inputFct :=  args[9];
	  errorList :=  listOfErrorsInInputList( actDAESys, initTime, inputFct);
	  if not
	    errorList=[]
	  then
	    errorMsg :=  convert(errorList, string);
	    error(errorMsg);
	  end if:

	  #
	  #initialize for later use in keeping track, when to change the input values according to the inputFctList
	  #
	  inputParamName := lhs(actDAESys[Parameters][1]);
	  inputFctCounter := 1
	else
	  inputFct := [];
	end if: 

	#
	#check if startTime is larger than initTime+interval, because this is actually the first timepoint where the sensitivities and trajects
	#are derived
	#
	if
	(startTime < initTime)
	then
	  error("second parameter has to be larger then the fifth");
	end if:


        #-----------------------------------------------------------------------------------------------
	#
	#calculate Sensitivities and Trajectories in the spezified interval with the spezified stepwidth
	#
	#-----------------------------------------------------------------------------------------------

	if
	  nargs = 9
	then
	  trajeSen:= CreateODESolSenAnal(DDASPKproc,
	    DDASPKsenRepeat, 
	    endTime,
	    interval,
	    initTime,
	    initVars,
	    inputFct
	  ):
	else
	  trajeSen:= CreateODESolSenAnal(DDASPKproc,
	    DDASPKsenRepeat, 
	    endTime,
	    interval,
	    initTime,
	    initVars
	  ):
	end if:  

	trajeSenCurve:= trajeSen[1];
	trajeSenNames:=trajeSen[2];
	data := trajeSenCurve:-GetData();

	#
	#get the number of points in trajeSenCurve
	#
	timePoints:=trajeSenCurve:-GetNumPoints();

        #
	#determine at which position in data[time] startTime is reached; it is guaranteed, that startTime is in the right boundaries
	#
	actStartPosition :=  0;
	if
	  (startTime=initTime)
	then
	  actStartPosition := 1;
	else
	   for f from 1 to timePoints do:
	     actItem :=  data[time][f];
	     if
	       (actItem>= startTime)
	     then
	       actStartPosition := f;
	       break;
	     end if:
	   end do:
	end if:

	#
	#create Jakobian regarding the Parameters and regarding the variables
	#
	jakobianPars := linalg[jacobian](map(rhs, outputFnctList),paramList);
	jakobianVars := linalg[jacobian](map(rhs, outputFnctList),varsList);
	
	#
	#Initialize hessianAnalytic
	#
	hessianAnalytic := Matrix(1..nrParams, 1..nrParams, shape = symmetric);

	#------------------------------------------------------------------------
	#
	#fill hessianmatrix
	#
	#------------------------------------------------------------------------

	#
	#l stands for the row of the hessianAnalytic
	#
     	for l from 1 to nrParams do:
	  firstParam :=  paramList[l];

	  #
	  #k stands for the column of the hessianAnalytic
	  #
	  for k from l to nrParams do:
	    secondParam :=  paramList[k];
	    sumOverTime := 0;

	    #
	    #Sum over Time
	    #
	    for i from actStartPosition to timePoints do:
	      sumOverFunct := 0;
	      actTime := data[time][i];

	      #
	      #contains substitution list for all trajectory values: list(state_i = value) 
	      #
	      actVarsValues:= [seq(
	        trajeSenNames[h]=data[trajeSenNames[h]][i],
		h = 1..nrVars
	      )];
	      subsList:=[op(actVarsValues), op(actDAESys[SenPars])];

	      #
	      #Sum over response functions
	      #
	      for j from 1 to nrFnct do:
	        sumOverVarsL := 0;
		sumOverVarsK := 0;
		actJakobianParsL := jakobianPars[j,l];
		actJakobianParsK := jakobianPars[j,k];
	      
		#
		#Sum over statevariables
		#
		for m from 1 to nrVars do:
                  actState:= varsList[m];
		  actSensNameL := cat('d',actState,'d',firstParam);
		  actSensNameK := cat('d',actState,'d',secondParam);

		  #
		  #get the sensitivities values
		  #
		  actSensValueL := data[actSensNameL][i];
		  actSensValueK := data[actSensNameK][i];
		  actJakobianVars := jakobianVars[j,m];

		  #
		  #calculate dg/dp's for fixed timePoint and fixed response function
		  #
		  sumOverVarsL := sumOverVarsL +subs(subsList,actJakobianVars)*actSensValueL;
		  sumOverVarsK := sumOverVarsK +subs(subsList,actJakobianVars)*actSensValueK;

                end do:
		#
		#sum dgJ/dps for all response functions j and add jakobian of gj  respective parameter (pl or pk) 
		#
		dgJdParamL := sumOverVarsL + subs(subsList,actJakobianParsL);
		dgJdParamK := sumOverVarsK + subs(subsList,actJakobianParsK);

		#
		#multiply both dgm/dpl and dgm/dpk and sum all products over all function gj
		#
		sumOverFunct:= sumOverFunct + dgJdParamL*dgJdParamK;
              end do:

	      #
	      #sum over all timepoints
	      #
	      sumOverTime := sumOverTime+sumOverFunct;
            end do:

	    #
	    #fill Hessian at Position [l,k]
	    #
	    hessianAnalytic[l,k] := evalf(sumOverTime);

	  end do:
	end do:
	return hessianAnalytic:
      end proc:	


      ##################################################################################################################
      # input: DDASPKproc -> Instance of DDASPKproc, containing the DAESys of interest
      #	       DDASPKsenRepeats -> Defines the number of integration repetitions for DDASPKSen      
      #        startTime -> left border of integration interval
      #        endTime -> right border of integration interval
      #        interval -> distance between points within the integration interval
      #        initTime ->startcondition for solution of the DAESys
      #        initVars -> values of the Variables at initTime
      #        outputFnctList-> list of equations, containing the response functions
      # output: an array containing two 2D arrays. The first array contains the analytical Solution of the Hessian matrix,
      #         and the second stores the numerical solution of the Hessian matrix)
      #         and numericaly (second entry)
      # todo: check correct format of the outputfunction (implement small function)
      ##################################################################################################################
      CompareAnalyticDDASPKSenHessian :=  proc(DDASPKproc::`module`,
        DDASPKsenRepeats::integer,
        startTime::numeric,
	endTime::numeric,
	interval::numeric,
	initTime::numeric,
	initVars::list(numeric),
	outputFnctList::list(equation)
	#optional Parameter inputFctList::list([numeric,numeric])
      )

        local DDASPKSenHessian, analyticHessian, result, senParsList, varsList, trajeSensNum, actDAESys:

	#
	#Define important variables
	#
	actDAESys:= DDASPKproc:-GetSys();
	senParsList:= map(lhs,actDAESys[SenPars]);
	varsList:= actDAESys[DynVars];

	#    
        #check if optional parameter is used
	#
	if
	  nargs=9
	then

	  trajeSensNum:= CreateODESolSen(DDASPKproc,
	    DDASPKsenRepeats,
	    endTime,
	    interval,
	    initTime,
	    initVars,
	    args[9]
	  );


	  analyticHessian:= CreateAnalyticHessian(DDASPKproc,
            DDASPKsenRepeats,
	    startTime,
	    endTime,
	    interval,
	    initTime,
	    initVars,
	    outputFnctList,
	    args[9]
        )	  

	else

	trajeSensNum:= CreateODESolSen(DDASPKproc,
	    DDASPKsenRepeats,
	    endTime,
	    interval,
	    initTime,
	    initVars
	  );

	analyticHessian:= CreateAnalyticHessian(DDASPKproc,
          DDASPKsenRepeats,
	  startTime,
	  endTime,
	  interval,
	  initTime,
	  initVars,
	  outputFnctList
        );


	end if:

	#
	#create Hessian
	#
	DDASPKSenHessian:=CreateHessian(DDASPKproc,
	  trajeSensNum,
          DDASPKsenRepeats,
	  startTime,
	  endTime,
	  varsList,
	  senParsList,
	  outputFnctList
        ); 


	result :=  array(1..2);

	result[1] :=  analyticHessian;
	result[2] :=  DDASPKSenHessian;

	return result:
      end proc:



      ##################################################################################################################
      # input: DDASPKproc -> instance of DDASPKSen, containing the DAESys of interest
      #	       DDASPKsenRepeats -> Defines the number of integration repetitions for DDASPKSen      
      #        firstWindow -> position of the first window
      #        lastWindow -> position of the last window
      #        winSize -> window size
      #        winStep -> movement of one window
      #        interval -> interval of points in one window
      #        initTime ->startcondition for solution of the DAESys
      #        initVars -> values of the Variables at initTime
      #        outputFnctList-> list of equations, containing the response functions
      #        num -> 1 => calculate numerical (default), 0 =>calculate Analytical if solution exists
      #	optional input: inputFct -> list containing tupels: [time, newInput]. Each tupel describes the timepoint, when
      #				    when the input should be changed, and the new value for the input
      # output: Eigenvectors of the HessianMatrix of function phi, calculated numericaly, for an sliding window
      ##################################################################################################################
      SlidingWindowCalculation :=  proc(DDASPKproc::`module`,
        DDASPKsenRepeats::integer,
        firstWindow::numeric,
	lastWindow::numeric,
	winSize::numeric,
	winInterval::numeric,
	interval::numeric,
	initTime::numeric,
	initVars::list(numeric),
	outputFnctList::list(equation),
	num := 1
	#optional input::list([numeric,numeric])
      )

      local actDAESys, actEValue, allEValues, actHessian,inputFct, errorList, errorMsg, 
        actWinStart, actWinEnd, i, varsList, parsList, endTime, ODESolSen;

	#
	#define important variables
	#
	actDAESys :=  DDASPKproc:-GetSys();
	varsList:= actDAESys[DynVars];
	parsList:= map(lhs, actDAESys[SenPars]);

	#
	#check if Parameters are correct
	#
	if
	  (firstWindow >=lastWindow)
	then
	  error("second parameter has to be smaller than third")
	elif
	  ((firstWindow +winInterval) > lastWindow)
	then
	  error("there will not occur any window sliding, because 2nd +5th paramter are larger than 3rd parameter")
	end if:



        #-------------------------------------------------------------------------------------------
	#
	#check if optional parameter is used, and has the right format, check additional conditions
	#
	#-------------------------------------------------------------------------------------------
	if
	  (nargs = 12)
	then
	  inputFct :=  args[12];
	  errorList :=  listOfErrorsInInputList( actDAESys, initTime, inputFct);
	  if not
	    errorList=[]
	  then
	    errorMsg :=  convert(errorList, string);
	    error(errorMsg);
	  end if:

	else
	  inputFct := [];
	end if: 

	#----------------------------------------------------------------------------------------------------
	#
	# Create the ODESolution
	#
	#----------------------------------------------------------------------------------------------------
	if num=1 then:
	  endTime:= lastWindow + winSize;

	  #
	  #check if variable input is used
	  #
	  if
	    inputFct=[]
	  then
	    #
	    #solve without variable input
	    #
	    ODESolSen :=  CreateODESolSen(DDASPKproc,
	      DDASPKsenRepeats,
	      endTime ,
	      interval,
	      initTime,
	      initVars
	    );
	  else
	    #
	    #solve without variable input
	    #
	    ODESolSen :=  CreateODESolSen(DDASPKproc,
	      DDASPKsenRepeats,
	      endTime ,
	      interval,
	      initTime,
	      initVars,
	      inputFct
	    );
	  end if:
	end if:
	

	#
	#slide the window over the timepoints from firstWindow to lastWindow. Each window has the size winSize and the window is moved
	#per step as defined by winInterval. For each window calculate the HessianMatrix and Store the EValues in allEValues
	#
	allEValues := [];
	i := 0;
	actWinStart := firstWindow;
	while actWinStart<lastWindow do:
	  actWinStart := firstWindow+i*winInterval;
	  actWinEnd := firstWindow +winSize+i*winInterval;

	  if num=1 then:
	     actHessian :=  CreateHessian(DDASPKproc,
	       ODESolSen,
	       DDASPKsenRepeats,
	       actWinStart,
	       actWinEnd,
	       varsList,
	       parsList,
	       outputFnctList);
          #
	  #check if variable input is used if num!=1 => analytic solution is seeked
	  #	 
	  else 
	    if	      
	      inputFct= []
	    then  
	      actHessian :=  CreateAnalyticHessian(DDASPKproc,
	        DDASPKsenRepeats,
	        actWinStart,
	        actWinEnd,
	        interval,
	        initTime,
	        initVars,
	        outputFnctList
	      );
	    else
	      actHessian :=  CreateAnalyticHessian(DDASPKproc,
	        DDASPKsenRepeats,
	        actWinStart,
	        actWinEnd,
	        interval,
	        initTime,
	        initVars,
	        outputFnctList,
	        inputFct
	      );	      
	    end if:
	  end if:   
	     
	  actEValue :=  [linalg[eigenvalues](actHessian)];
	  allEValues :=  [op(allEValues), actEValue];
	  i := i+1;
	end do:
	return allEValues:

      end proc:


      ##################################################################################################################
      # input: trajeSens -> module of type Curve, has to be created with function CreateODESolSen
      #	       varsList -> to check, wether the trajeSens contains the right variables
      #	       senParsList -> selection of Parameters, for which the Hessian should be calculatedx
      #        startTime -> left border of integration
      #        endTime -> right border of integration
      #        outputFnctList-> list of equations, containing the response functions (g(x(t),p,u(t)))
      # output: tripel:  [eigenvalues, eigenvectorMatrix, HessianMatrix, trajeSens];
      #	       Contains the Eigenvalues and the Eigenvectors of the HessianMatrix of function phi and a curve Object containing the
      #	       the trajectories and the sensitivities;
      # todo: 1.check correct format of the outputfunction (implement small function), catch wrong option input
      #	      2.exchange list structures for arrays allEVectors, allEValues
      ##################################################################################################################
      ComputeEigenvectorsOfHessianForSelectedParameters := proc(trajeSens::`module`,
	varsList::list(name),
	senParsList::list(name),
        startTime::numeric,	
	endTime::numeric,
        outputFnctList::list(equation)
	# optional parameter inputFctList::list([numeric,numeric])
      )

      local actDAESys, nrPars, inputFct, errorList, errorMsg, ODESolSen, actHessian, eigenvectors, eigenvalues, eigenvectorMatrix;

	#
	#define important variables
	#
	nrPars:= nops(senParsList);

	#
	#check correct Parameters
	#
	if
	  (startTime >=endTime)
	then
	  error("third parameter has to be smaller than fourth")
	end if:

        actHessian :=  CreateHessianForSelectedParameters(trajeSens,
	  varsList,
	  senParsList,
	  startTime,
	  endTime,
	  outputFnctList
        );

	#
	#Eigenvectors returns a tupel of first a column vector containing the eigenvalues and then a matrix, where each column represents the
	#Eigenvector
	#
	eigenvectors :=  [LinearAlgebra[Eigenvectors](actHessian)];
	eigenvalues:= eigenvectors[1];
	eigenvectorMatrix:= eigenvectors[2];

        return [eigenvalues, eigenvectorMatrix, actHessian, trajeSens]:
	
      end proc:


      ##################################################################################################################
      # input: inputVector -> column vector dimension n, each element contains a skalar (e.g. length, eValue) for the
      #			 corresponding column vector of the second input parameter
      #	       inputMatrix -> matrix, dimension m*n
      #	       criterion -> string containing the criterion for selecting the vectors:  ">", "<", "="
      #	       value -> number setting the limit for the selection criterion
      #	
      # output: outputList -> each list elemtent contains a list containing a tupel [vector,value] for each column vector
      #			      whose scalars (from vector) fullfill the requirements  
      ##################################################################################################################
       SelectSpecificColumnsFromMatrix:=  proc(inputVector::Vector,
        inputMatrix::Matrix,
	criterion::string,
	value::numeric
      )

      local matrixDimension, nrMatrixRows, nrMatrixColumns, nrVectorElements, setOfCriterionStrings, i,outputList, actElement;

	#
	#introduce important variables
	#
	matrixDimension:= LinearAlgebra[Dimension](inputMatrix):
	nrMatrixRows:= matrixDimension[1]:
	nrMatrixColumns:= matrixDimension[2]:
	nrVectorElements:= LinearAlgebra[Dimension](inputVector):
	outputList:= [];

	setOfCriterionStrings:= {">", "<", "="}:

	#
	#check that inputVector has the same dimension as inputMatrix has numbero of columns
	#
	if not
	  nrMatrixColumns = nrVectorElements
	then
	  error("Number of elements in inputVector must be the same as the number of columns in inputMatrix")        
	end if:

	#
	#check if criterion is element of the set relvant stings
	#
	if not
	  criterion in setOfCriterionStrings
	then
	  error("the third element has to be a string from the set: {\">\", \"<\",\" =\"}");
	end if:

	#
	#do the selection step
	#
	for i from 1 to nrVectorElements do:
	  actElement:= inputVector[i]:

	  #
	  #evaluate the criterion
	  #
	  if
	    criterion = ">"
	  then

	    if
	      actElement > value
	    then
	      outputList:=[op(outputList), [LinearAlgebra[Column](inputMatrix, i), actElement]]:
	    end if:

	  elif
	    criterion = "<"
	  then

	    if
	      actElement < value
	    then
	      outputList:=[op(outputList), [LinearAlgebra[Column](inputMatrix, i), actElement]]:
	    end if:

	  else

	    if
	      actElement = value
	    then
	      outputList:=[op(outputList), [LinearAlgebra[Column](inputMatrix, i), actElement]]:
	    end if:

	  end if:
	end do:

	return outputList:
      
      end proc:

      ##################################################################################################################
      # input: inputVector -> column vector dimension n, each element contains a skalar (e.g. length, eValue)
      #	       criterion -> string containing the criterion for selecting the vectors:  ">", "<", "="
      #	       value -> number setting the limit for the selection criterion
      #	
      # output: outputList -> list of tuples [position, values] of all elements of the vector, that fulfills the criterion
      ##################################################################################################################
       SelectLargestEntrieFromVectors:=  proc(inputVector::Vector,
	criterion::string,
	value::numeric
      )

      local matrixDimension, nrMatrixRows, nrMatrixColumns, nrVectorElements, setOfCriterionStrings, i,outputList, actElement;

	#
	#introduce important variables
	#
	nrVectorElements:= LinearAlgebra[Dimension](inputVector):
	outputList:= [];

        setOfCriterionStrings:= {">", "<", "=", "|>|"}:

	#
	#check if criterion is element of the set relvant stings
	#
	if not
	  criterion in setOfCriterionStrings
	then
	  error("the third element has to be a string from the set: {\">\", \"<\",\" =\"}");
	end if:

	#
	#do the selection step
	#
	for i from 1 to nrVectorElements do:
	  actElement:= inputVector[i]:

	  #
	  #evaluate the criterion
	  #
	  if
	    criterion = ">"
	  then

	    if
	      actElement > value
	    then
	      outputList:=[op(outputList), [i, actElement]]:
	    end if:

	  elif
	    criterion = "<"
	  then

	    if
	      actElement < value
	    then
	      outputList:=[op(outputList), [i, actElement]]:
	    end if:

	  elif
	    criterion = "|>|"
	  then

	    if
	      abs(actElement)> value 
	    then
	      outputList:=[op(outputList), [i, actElement]]:
	    end if:

	  else

	    if
	      actElement = value
	    then
	      outputList:=[op(outputList), [i, actElement]]:
	    end if:

	  end if:
	end do:

	return outputList:
      
      end proc:


      ##################################################################################################################
      # input: DDASPKproc -> instance of DDASPKSen, containing the DAESys of interest
      #	       DDASPKsenRepeats -> Defines the number of integration repetitions for DDASPKSen      
      #        extensionStart -> position of the extension start
      #        extensionEnd -> position of the extension end
      #        initExtensionSize -> size of the first extension frame
      #        extStep -> enlargement of the extension
      #        interval -> interval of points in one window
      #        initTime ->startcondition for solution of the DAESys
      #        initVars -> values of the Variables at initTime
      #        outputFnctList-> list of equations, containing the response functions
      #        numeric -> true => calculate numerical (default), false =>calculate Analytical if solution exists
      #	optional input: inputFct -> list containing tupels: [time, newInput]. Each tupel describes the timepoint, when
      #				    when the input should be changed, and the new value for the input
      # output:tupel, [List of EigenvectorResults, curve Object];
      #	       Eigenvectors of the HessianMatrix of function phi, calculated numericaly for an extending window;
      #	       the curve object strores the Eigenvalues. It contains the entries: expIndex, evalue1 ....evaluen
      # todo: 1a: check if intervall has a correct value: it shouldnt be to large IMPORTANT
      #	      1.check correct format of the outputfunction (implement small function), catch wrong option input
      #	      2.create an expansion index with more information
      #	      3.exchange list structures for arrays allEVectors, allEValues
      ##################################################################################################################
      ExtendingWindowCalculation :=  proc(DDASPKproc::`module`,
        DDASPKsenRepeats::integer,
        extensionStart::numeric,
	extensionEnd::numeric,
	initExtensionSize::numeric,
	extStep::numeric,
	interval::numeric,
	initTime::numeric,
	initVars::list(numeric),
	outputFnctList::list(equation),
	numerik::boolean
	#optional input::list([numeric,numeric])
      )

      local actDAESys, actEValue, allEValues, actHessian, actExtEnd , i, varsList, parsList, ODESolSen, inputFct, errorList, errorMsg, nrPars,
        numEValues, eValueData, eValueNames, m, actName, h, g, actNomen, otherData, curve, actComplex, actEVectors, allEVectors;

	#
	#define important variables
	#
	actDAESys :=  DDASPKproc:-GetSys();
	varsList:= actDAESys[DynVars];
	parsList:= map(lhs, actDAESys[SenPars]);
	nrPars:= nops(parsList);
	allEVectors := [];
	#
	#check correct Parameters
	#
	if
	  (extensionStart >=extensionEnd)
	then
	  error("second parameter has to be smaller than third")
	elif
	  ((extensionStart + initExtensionSize) > extensionEnd)
	then
	  error("there will not occur any extension, because 2nd +4th paramter are larger than 3rd parameter")
	elif
	  (extStep = 0)
	then
	  error("parameter 7 has to be > 0");
#	elif
#	  (interval>= extStep)
#	then
#	  error("parameter 7 has to be < than parameter 6")
#	elif
#	  (interval>= initExtensionSize)
#	then
#	  error("parameter 7 has to be < than parameter 5")
	end if:


        #-------------------------------------------------------------------------------------------
	#
	#check if optional parameter is used, and has the right format, check additional conditions
	#
	#-------------------------------------------------------------------------------------------
	if
	  (nargs = 12)
	then
	  inputFct :=  args[12];
	  errorList :=  listOfErrorsInInputList( actDAESys, initTime, inputFct);
	  if not
	    errorList=[]
	  then
	    errorMsg :=  convert(errorList, string);
	    error(errorMsg);
	  end if:

	else
	  inputFct := [];
	end if: 

	
	#----------------------------------------------------------------------------------------------------
	#
	#Create the ODESolution
	#
	#----------------------------------------------------------------------------------------------------
	if
	  numerik
        then:
	  #
	  #check if variable input is used
	  #
	  if
	    inputFct=[]
	  then
	    #
	    #without variable input
	    #
	    ODESolSen :=  CreateODESolSen(DDASPKproc,
	      DDASPKsenRepeats,
	      extensionEnd+1 ,
	      interval,
	      initTime,
	      initVars
	    ):

	  else
	    #
	    #with variable input
	    #
	    ODESolSen :=  CreateODESolSen(DDASPKproc,
	      DDASPKsenRepeats,
	      extensionEnd+1 ,
	      interval,
	      initTime,
	      initVars,
	      inputFct
	    );
	  end if:
	end if:

	allEValues := [];
	i := 1;
	
	actExtEnd := extensionStart+initExtensionSize;
	while actExtEnd <=  extensionEnd do:
	  
          if
	    numerik
	  then
	    actHessian :=  CreateHessian(DDASPKproc,
	      ODESolSen,
	      DDASPKsenRepeats,
	      extensionStart,
	      actExtEnd,
	      varsList,
	      parsList,
	      outputFnctList
	    );

          else

	    #
	    #check if variable input is used
	    #
	    if
	      inputFct=[]
	    then  
	      #
	      #without variable input
	      #
	      actHessian :=  CreateAnalyticHessian(DDASPKproc,
		DDASPKsenRepeats,
		extensionStart,
		actExtEnd,
		interval,
		initTime,
		initVars,
		outputFnctList
	      );

	    else
	      #
	      #with variable input
	      #
	      actHessian :=  CreateAnalyticHessian(DDASPKproc,
		DDASPKsenRepeats,
		extensionStart,
		actExtEnd,
		interval,
		initTime,
		initVars,
		outputFnctList,
		inputFct
	      );
	    end if:
          end if:

	  #
	  #Eigenvectors returns a tupel of first a column vector containing the eigenvalues and then a matrix, where each column represents the
	  #Eigenvector
	  #
	  actEVectors :=  [LinearAlgebra[Eigenvectors](actHessian)];
	  actEValue:= actEVectors[1];
	  actEValue:= convert(actEValue, list);
	  #
	  #actEValue may contain imaginary Parts in that case throw a error, otherwise discard the 0.I part (can be adressed
	  # by op(2, complex) ) of the complex number
	  #

#          for h from 1 to nops(actEValue) do:
#	    actComplex:= actEValue[h];
#	    DEBUG();
#	    #
#	    #first check if actComplex is of type complex
#	    #
#	    if
#	      hastype(actComplex, complex)	
#	    then
#	      if
#	        op(2,actComplex)= 0
#	      then
#	        actEValue[h]:= op(1,actComplex);
#	      else
#	        ERROR("EValues contain complex Numbers");
#	      end if:
#	    end if:  
#	  end do:
	  actEValue:= sort(actEValue);
          allEValues :=  [op(allEValues), actEValue];
          allEVectors := [op(allEVectors), actEVectors];
	  #
	  #update actExtEnd for the next expansion; add 1 to i
	  #
	  actExtEnd := extensionStart +initExtensionSize+i*extStep;
          i := i+1;
	end do:

	numEValues:= nops(allEValues);
	
	#----------------------------------------------------------------------------------------------------
	#
	#initialize table eValueData, that stores the eValues and the corresponding expansion end
	#
	#----------------------------------------------------------------------------------------------------
	eValueData:= table();

	#
	#initialize one array for the number of extension times
	#
	eValueData[expIndex]:= array(1..numEValues);

	#
	#initialize one array for each eValue
	#
	eValueNames:=[];
	for m from 1 to nrPars do:
	  actName:= cat(evalue, m);
	  eValueNames:= [op(eValueNames),actName]:
	  eValueData[actName]:= array(1..numEValues);
	end do:

	#----------------------------------------------------------------------------------------------------
	#
	#fill the calculated e-values into the table eValueData
	#
	#----------------------------------------------------------------------------------------------------
	for h from 1 to numEValues do:
	  eValueData[expIndex][h]:= h;

	  for g from 1 to nops(eValueNames) do:
	    actNomen:= eValueNames[g];
	    eValueData[actNomen][h]:= allEValues[h][g]; 
	  end do:
	  
	end do:
	
	#----------------------------------------------------------------------
	#
	#create Curve Object that contains the timepoints, the trajectories and
	#the sensitivities
	#
	#----------------------------------------------------------------------
	otherData := ['NumPoints'=numEValues, Parameters=[]];
	curve := ModelPack:-CreateCurve(eValueData,otherData);
        return [allEVectors,curve]:
	
      end proc:

      ##################################################################################################################
      # input: DDASPKproc -> instance of DDASPKSen, containing the DAESys of interest
      #	       DDASPKsenRepeats -> Defines the number of integration repetitions for DDASPKSen      
      #        start=> last position to start the different compare cycles (it will start from zero)
      #        nrExtension => extend the intervall with 1 for each step until start+nrExtension ;
      #        nrInterval => defines what intervals are used for Hessian Calculation during compare
      #                      {1/100, 2/100....nrInterval/100}
      #        initVars => list of numerics, representing the values of the initial variables
      #        FctList => list of equations, containing the response functions
      # output: Curve object (see ModelPack), containing the hessian Entries for all different settings, from both numeric
      #         and analytic calculation. Each entry can be accesssed via the regular Expression hess{Anal,Num}Pij (i and j
      #         denote the matrix position).
      ##################################################################################################################
      CompareSeveral :=  proc(DDASPKproc::`module`,
        DDASPKsenRepeats::integer,
        start::integer,
        nrExtension::integer,
        nrInterval::integer,
        initVars::list(numeric),
        FctList::list(equation)
	# optional Parameter inputFctList::list([numeric,numeric])
      )

      local AnalyticNumeric, i, j, k, m, n, o, p, iter, dimension, comparedResults,actDAESys,
        nameAnal, nameNum, otherData, returnCurve, numCalc, errorList, errorMsg, inputFct;

	actDAESys:= DDASPKproc:-GetSys();
	
        #-------------------------------------------------------------------------------------------
	#
	#check if optional parameter is used, and has the right format, check additional conditions
	#
	#-------------------------------------------------------------------------------------------
	if
	  (nargs = 8)
	then
	  inputFct :=  args[8];
	  errorList :=  listOfErrorsInInputList( actDAESys, start, inputFct);
	  if not
	    errorList=[]
	  then
	    errorMsg :=  convert(errorList, string);
	    error(errorMsg);
	  end if:

	  #
	  #initialize for later use in keeping track, when to change the input values according to the inputFctList
	  #
#	  inputParamName := lhs(actDAESys[Parameters][1]);
#	  inputFctCounter := 1

	end if:  
	  
	AnalyticNumeric :=  table();
	numCalc :=  start*nrExtension*nrInterval;
	iter := 1;
	for i from 1 to start do:

	  #
	  #iterate the endTimes
	  #
	  for j from 1 to nrExtension do:

	    #
	    #iterate the intervallpoints
	    #
	    for k from 1 to nrInterval do:

	      #
	      #we are working with variable input
	      #
	      if     
	        nargs = 8
	      then
	        comparedResults := CompareAnalyticDDASPKSenHessian(DDASPKproc,DDASPKsenRepeats, i-1,i-1+j,k*1/100,0,initVars,FctList,inputFctList);
	        dimension := rhs(op(2, eval(comparedResults[1]))[1]);
	      else
	        comparedResults := CompareAnalyticDDASPKSenHessian(DDASPKproc,DDASPKsenRepeats, i-1,i-1+j,k*1/100,0,initVars,FctList);
	        dimension := rhs(op(2, eval(comparedResults[1]))[1]);
	      end if:
	      #
	      #initialize AnalyticNum
	      #
	      if
		iter=1
	      then:
		for m from 1 to dimension do:
		  for n from 1 to dimension do:
		    nameAnal := cat('hessAnalP',m,n);
		    nameNum := cat('hessNumP',m,n);
		    AnalyticNumeric[nameAnal] := array(1..numCalc);
		    AnalyticNumeric[nameNum] := array(1..numCalc);
		    AnalyticNumeric[position] := array(1..numCalc);
		  end do:
		end do:
	      end if;

	      #
	      #fill AnalyticNum
	      #
	      for o from 1 to dimension do:
		for p from 1 to dimension do:
		  nameAnal := cat('hessAnalP',o,p);
		  nameNum := cat('hessNumP',o,p);
		  AnalyticNumeric[nameAnal][iter] := comparedResults[1][o,p];
		  AnalyticNumeric[nameNum][iter] := comparedResults[2][o,p];
		  AnalyticNumeric[position][iter] := iter;
		end do:
	      end do:
	      iter :=  iter +1;

	    end do:
	  end do:
        end do:

        #
        #Create curve Object to be returned
        #
        otherData := ['NumPoints'=numCalc, Parameters=[]];
        returnCurve := ModelPack:-CreateCurve(AnalyticNumeric,otherData);
        return returnCurve;

      end proc:



      ##################################################################################################################
      # input: curve -> curve object
      #        outputFnctList => list containing the response function definition
      #	       paramList => list of parameter=EvalsToFlow
      #	       varsList => list of variables used
      # output: list of vectors: for each timepoint stored in curve, a vector will be created containing the values of the
      #	        output variables defined in outputFnctList.   
      ##################################################################################################################
      CurveToListOfVectorsExt:= proc(curve, 
	outputFnctList::list(name=algebraic),
	paramList::{list(name=EvalsToFloat),[]},
	varsList::list(name)
	)
	local data, curveIndices, nrPoints, nrVars, tmpVarsSet, listOfVectors, i, actVector, j, actIndex,paramNames, listOfErrors, errMsg, nrOutputs,
	subsedOutputFnctList, actVarsList,k , actVars, actValue, actRHS, actOutput ;

	#
	#check if input parameter is of type curve
	#
	try
	  data:=curve:-GetData():
	catch "module does not export `%1`":
	  ERROR("first input parameter has to be of type curve"):
	end try:

	#
	#check if outputList is correct, meaning its rhs only contains operands out of varsList and/or the lhs of paramList
	#
	paramNames:=map(lhs, paramList);
	listOfErrors := listOfErrorsInOutputFunctions(paramNames,
	  varsList,
	  outputFnctList
	);

	#
	#if there has been an error, throw an exception with the corresponding message
	#
	if not
	  listOfErrors=[]
	then
	  errMsg:=convert(listOfErrors,string);
	  error errMsg;
	end if:	

	#
	#create important variables
	#
	data:= curve:-GetData();
	curveIndices:= {indices(data)}:
	nrPoints:= curve:-GetNumPoints():
	nrVars:= nops(varsList):
	nrOutputs:= nops(outputFnctList);

	#
	#check if variables in last input parameter are stored in the curve object
	#
	tmpVarsSet:={seq([varsList[i]],i=1..nrVars)};
	if not
	  tmpVarsSet subset curveIndices
	then
	  ERROR("last parameter contains variables not specified in the curve object (first parameter)"):
	end if:

	#
	#substitute paramList in the outputFnctList
	#
	subsedOutputFnctList:= subs( paramList, outputFnctList);

	#
	#create list of Vectors
	# 
	listOfVectors:=[];
	for i from 1 to nrPoints do:
	  actVector:=Vector(1..nrOutputs):
	  actVarsList:=[];
	  for k from 1 to nrVars do:
	    actVars:= varsList[k];
	    actValue:= data[actVars][i];
	    actVarsList:= [op(actVarsList),actVars=actValue];
	  end do:

	  for j from 1 to nrOutputs do:
	    actRHS:= rhs(subsedOutputFnctList[j]):
	    actOutput:= subs(actVarsList, actRHS);
	    actVector[j]:=actOutput;
	  end do:
	  listOfVectors:=[op(listOfVectors), actVector];
	end do:
	return listOfVectors:

      end proc:


      ##################################################################################################################
      # input: curve -> curve object
      #        listOfVariables => list of variables, that will be converted into one vector for each time point.
      #			          all variable names in this list, must be represented in the curve object, otherwise an
      #				  exception is raised
      # output: list of vectors: for each timepoint stored in curve, a vector will be created containing the values of the
      #	        variables defined in listOfVariables.   
      ##################################################################################################################
      CurveToListOfVectors:= proc(curve, 
	listOfVariables::list(name)
	)
	local data, curveIndices, nrPoints, nrVars, tmpVarsSet, listOfVectors, i, actVector, j, actIndex;

	#
	#check if input parameter is of type curve
	#
	try
	  data:=curve:-GetData():
	catch "module does not export `%1`":
	  ERROR("first input parameter has to be of type curve"):
	end try:


	#
	#create important variables
	#
	data:= curve:-GetData();
	curveIndices:= {indices(data)}:
	nrPoints:= curve:-GetNumPoints():
	nrVars:= nops(listOfVariables):  

	#
	#check if variables in second input parameter are stored in the curve object
	#
	tmpVarsSet:={seq([listOfVariables[i]],i=1..nrVars)};
	if not
	  tmpVarsSet subset curveIndices
	then
	  ERROR("second parameter contains variables not specified in the curve object (first parameter)"):
	end if:

	#
	#create list of Vectors
	# 
	listOfVectors:=[];
	for i from 1 to nrPoints do:
	  actVector:=Vector(1..nrVars):
	  for j from 1 to nrVars do:
	    actIndex:= listOfVariables[j]:
	    actVector[j]:=data[actIndex][i];
	  end do:
	  listOfVectors:=[op(listOfVectors), actVector];
	end do:
	return listOfVectors:

      end proc:





      ##################################################################################################################
      # input: simVecList -> list of vectors, corresponding to simulated results 
      #        realVecList -> list of vectors, corresponding to real results
      # output:least squares difference between the list of vectors
      # notes : the list of vectors have the following structure: each vector contains values for all outputs of the system
      #		for one specific timepoint		
      ##################################################################################################################
      Lsq:= proc(simVecList::list(Vector), 
        realVecList::list(Vector)
        )
        local nrElements, nrTimePoints, result, i, difference;
        nrTimePoints:=nops(simVecList):  
        if not
          nops(simVecList)= nops(realVecList)
        then
          ERROR("simulated and real Data have to contain the same number of elements")
        else
          result:= 0:
          for i from 1 to nrTimePoints do:
            difference:= simVecList[i]-realVecList[i]:
            result := result + difference.difference:
          end do:  
        end if:
        return 1/2*result:
      end proc:

      ##################################################################################################################
      # input: listA -> a list of numeric values
      #	       listB -> a list of numeric values
      # output: true -> if the absolute value of the first element of listA > absolute value of the first element of listB
      #		false ->if the absolute value of the first element of listA <= absolute value of the firts element of listB
      ##################################################################################################################
      firstListElementAbsIsLarger:= proc(listA::list(numeric), listB::list(numeric)
       )
	local firstElementA, firstElementB, result:
	firstElementA:=abs(listA[1]):
	firstElementB:=abs(listB[1]):
	return evalb(firstElementA>=firstElementB);
      end proc:


      ##################################################################################################################
      # input: listA -> a list of numeric values
      #	       listB -> a list of numeric values
      # output: true -> if the absolute value of the first element of listA < absolute value of the first element of listB
      #		false ->if the absolute value of the first element of listA >= absolute value of the firts element of listB
      ##################################################################################################################
      firstListElementAbsIsSmaller:= proc(listA::list(numeric), listB::list(numeric)
       )
	local firstElementA, firstElementB, result:
	firstElementA:=abs(listA[1]):
	firstElementB:=abs(listB[1]):
	return evalb(firstElementA<firstElementB);
      end proc:


      ##################################################################################################################
      # input: listA -> a list of values first element has to be numeric
      #	       listB -> a list of values first element has to be numeric
      # output: true -> if the  value of the first element of listA <  value of the first element of listB
      #		false ->if the  value of the first element of listA >=  value of the firts element of listB
      ##################################################################################################################
      firstListNumericElementIsSmaller:= proc(listA::list, listB::list
       )
	local firstElementA, firstElementB, result:
	firstElementA:=evalf(listA[1]):
	firstElementB:=evalf(listB[1]):
	if not
	  hastype(firstElementA,numeric) and hastype(firstElementB,numeric)
	then
	  error("%1 and %2 has to be numeric values.",firstElementA,firstElementB);
	end if:

	return evalb(firstElementA<firstElementB);
      end proc:



      ##################################################################################################################
      # input: inputVector -> column vector dimension n, each element contains a skalar (e.g. length, eValue)
      #	       nrMaxValues -> specifies the nr of largest elements returned in the listOutputTupel. 2 => the first and
      #			      second largest elements of the inputVector and the corresponding indices are returned.
      #	
      # output: listOutputTupel ->the nth tuple contains the nth largest absolute Element and its position
      ##################################################################################################################
      FindMaxAbsInVector:=  proc(inputVector::Vector,
        nrMaxValues::integer		
        )

	 local nrVectorElements,listValueIndexTupel, sortedTupels, nLargestTupel;
        	
	#
	#introduce important variables
	#
	nrVectorElements:= LinearAlgebra[Dimension](inputVector):

	#
	#error handling: nrMaxValues has to be between [1, nrVectorElements];
	#if there has been an error, throw an exception with the corresponding message
	#
	if
	  nrMaxValues > nrVectorElements
	then
	  error "second parameter has to be smaller or equal than the size of the first parameter";
	end if:


	#
	#create from the input vector a tuple list: each entry of the vector is saved as a tupel of [value, index of value]
	#this structure is necessary for sorting, because we can beware the position of the sorted element 
	#
	listValueIndexTupel:= [seq([inputVector[i],i],
	  i=1..nrVectorElements
	  )];
	  
	#
	#sort the tupel list in descending order by the first element of each tupel
	#
	sortedTupels:= sort(listValueIndexTupel,firstListElementAbsIsLarger);
	#
	#select the first n values, corresponding to the n largest elements (n= specified by second input parameter)
	#
	nLargestTupel:=sortedTupels[1..nrMaxValues];

	return nLargestTupel:
      
      end proc:


      ##################################################################################################################
      # input: inputVector -> column vector dimension n, each element contains a skalar (e.g. length, eValue)
      #	       nrMinValues -> specifies the nr of smallest elements returned in the listOutputTupel.Example nrMinValues:= 2 =>
      #			      the first and second smallest elements of the inputVector and the corresponding indices are returned.
      #	
      # output: listOutputTupel -> The smallest absolute Elements and its positions (how many elements are returned is
      #				   specified by the second input parameter nrMinValues.
      ##################################################################################################################
      FindMinAbsInVector:=  proc(inputVector::Vector,
        nrMinValues::integer		
        )

	 local nrVectorElements,listValueIndexTupel, sortedTupels, nSmallestTupel;
        	
	#
	#introduce important variables
	#
	nrVectorElements:= LinearAlgebra[Dimension](inputVector):

	#
	#error handling: nrMinValues has to be between [1, nrVectorElements];
	#if there has been an error, throw an exception with the corresponding message
	#
	if
	  nrMinValues > nrVectorElements
	then
	  error "second parameter has to be smaller or equal than the size of the first parameter";
	end if:


	#
	#create from the input vector a tuple list: each entry of the vector is saved as a tupel of [value, index of value]
	#this structure is necessary for sorting, because we can beware the position of the sorted element 
	#
	listValueIndexTupel:= [seq([inputVector[i],i],
	  i=1..nrVectorElements
	  )];

	#
	#sort the tupel list in descending order by the first element of each tupel
	#
	sortedTupels:= sort(listValueIndexTupel,firstListElementAbsIsSmaller);
	
	#
	#select the first n values, corresponding to the n largest elements (n= specified by second input parameter)
	#
	nSmallestTupel:=sortedTupels[1..nrMinValues];

	return nSmallestTupel:
      
      end proc:


      ##################################################################################################################
      # input: DDASPKproc -> module of type DDASPKSen
      #	       trajeSens -> module of type Curve, has to be created with function CreateODESolSen
      #        endTime -> right border of integration
      #        startTime -> left border of integration
      #        varsList -> contains the names of the dynamic variables;
      #        senParsList -> contains the names of the sensitivity parameters; 
      #        outputFnctList-> list of equations, containing the response functions (g(x(t),p,u(t)))
      #
      # output:  parameterCorrelationMatrix -> Matrix containing the correlation between parameters, evaluated from
      #					       the matrix of Sensitivities of the outputs regarding the parameters
      #	to do: change in the test cases, that now a correlation matrix is returned and not the gMatrix
      # to do: insert function CalculateGMatrix => all tests has to be repeated
      # reference: "Importance of Input Pertubations and Stochastic Gene Expression in the Reverse Engineering of Genetik
      #		   Regulatory Networks: Insights From an Identifiability Analysis of an In Silico Network", Zak 2003
      ##################################################################################################################
      CalculatePrioriParameterCorrelation:= proc(DDASPKproc::`module`,
        trajeSens::`module`,
        startTime::numeric,	
	endTime::numeric,
	varsList::list(name),
	senParsList::list(name),
        outputFnctList::list(equation)
      )
      
        local errList, endTimeOfSolution, listOfErrors, errMsg, data, sizeTrajeSens, actDAESys, nrVars, nrParams, nrFnct, initTime,
	  timePoints, actStartPosition, actEndPosition, startFlag, f, actItem, nrRowsOfG, nrColumnsOfG, matrixG, jakobianPars, jakobianVars,
	  i, VarsEqu, nrTimePoints, tmp, loopVars, subsList, j, l, actParam, sumOverVarsL, actJakobianParsL, m, actState, actSensNameL,
	  actSensValueL, actJakobianVars, dgJdParamL, gMatrix, correlationMatrix, rowCounter ;



	#
	#checks are done in CalculateGMatrix
	#

	gMatrix:= CalculateGMatrix(DDASPKproc,
          trajeSens,
          startTime,	
	  endTime,
	  varsList,
	  senParsList,
          outputFnctList
	);

	correlationMatrix:= Statistics[CorrelationMatrix](gMatrix, ignore = true);
	return correlationMatrix;

      end proc:

      ##################################################################################################################
      # input: aMatrix -> aMatrix
      #
      # output: a vector, containing the sum of each row
      #		
      ##################################################################################################################
      CalculateAbsoluteSumOfRow:= proc(aMatrix::Matrix)

      	local resultVector, nrRows, actRowSum, nrColumns, i, j:

	nrRows:=LinearAlgebra[Dimension](aMatrix)[1];
	nrColumns:=LinearAlgebra[Dimension](aMatrix)[2];
	resultVector:=Vector(nrRows);	
	
	#
	#iterate over all rows
	#
	for i from 1 to nrRows do:
	  actRowSum:=0;

	  #
	  #iterate over all columns
	  #
	  for j from 1 to nrColumns do:
	    actRowSum:= actRowSum+ abs(aMatrix[i,j]);
	  end do:

	  #
	  #fill the vector
	  #
	  resultVector[i]:=actRowSum;

	end do:

	return resultVector;

      end proc:

      ##################################################################################################################
      # input: aMatrix -> aMatrix
      #	       threshold -> numeric, that decides when parameters are correlated
      #
      # output: a vector, containing the sum of each row, for all elements larger than the second parameter threshold
      #		
      ##################################################################################################################
      CalculateSumOfSelectedValuesPerRow:= proc(aMatrix::Matrix,
        threshold::numeric)

      	local resultVector, nrRows, actRowSum, nrColumns, i, j, actValue:

	nrRows:=LinearAlgebra[Dimension](aMatrix)[1];
	nrColumns:=LinearAlgebra[Dimension](aMatrix)[2];
	resultVector:=Vector(nrRows);	
	
	#
	#iterate over all rows
	#
	for i from 1 to nrRows do:
	  actRowSum:=0;

	  #
	  #iterate over all columns
	  #
	  for j from 1 to nrColumns do:	

	    #
	    #only add an row element, if its absolute value is larger than threshold
	    #
	    actValue:= abs(aMatrix[i,j]);
	      if actValue>threshold
	    then
	      actRowSum:= actRowSum+ actValue;
	    end if:
	  end do:

	  #
	  #fill the vector
	  #
	  resultVector[i]:=actRowSum;

	end do:

	return resultVector;

      end proc:



      ##################################################################################################################
      # input: aDAESys ->DAE system of interest; has to be of type DAESys
      #	       DDASPKsenRepeats -> Defines the number of integration repetitions for DDASPKSen
      #	       endTime-> right border of integration
      #	       startTime -> left border of integration = start condition for the solution of the DAESys
      #	       interval -> disctance between points within the integration interval
      #	       initVars -> list of the Variables at start time -> start values for the variables used to solve the DAESys
      #	       senPars -> list containing the sensitivity parameter
      #	       outputFnctList -> list of equations, containing the response functions (g(x(t)), p, u(t))
      #	       reductionModus -> string or tupel [string, numeric], defining how to reduce the DAESys: "correlation", "random",
      #				 "eigenvalue", "Degenring1", "Degenring2", "Degenring3" (see Degenring2004 pp 736, 3.3), a list of list(name)
      #				 containing names of parameters, that should be iteratively removed (several list are then processed at the same time
      #				 , or ["correlation", threshold],
      #				 where threshold specifies the selection process in  the correlation reduction method.
      #				 See also documentation of: CalculateSumOfSelectedValuesPerRow.
      #	       threshold -> threshold for the smallest Eigenvalue (here defined as smallest absolute value of all eigenvalues.
      #			    If the smallest Eigenvalue of the Hessian of the reduced Modell is above this threshold =>
      #			    reduction is stopped and the Hessian is assumed to be singular => parameter estimation should be a possible.
      #	       calcPrecicion -> integer that fixes the precision of the calculation via Digit
      #	       dirName -> string that defines, where to store the DDASPKsen instance
      #	       scaled -> if true => the hessian is scaled as in Yao 2003 formula 6
      # optional argument : inputFct -> list containing tupels: [time, newInput]. Each tupel describes the timepoint, when
      #					 when the input should be changed, and the new value for the input
      #	       			 
      #
      # output: List containing [for list modus:0) additionally the actual list is added (in the case that several lists are used at position] 
      #				1) a list containing the removed parameters in the order of removal
      #				2) a list of the smallest Eigenvalue of the Hessianmatrix in each reduction iteration
      #				3) Hessian of the reduced Modell
      # to do1: the reductionModus version with ["correlation", value] is not pretty elegant, because I force the user to
      #	       write correlation, but it is not really necessary
      #	to do2: In each reduction step I have to calculate a new instance of DDASPKSen and calculate its solution + sensitivities,
      #		what is very expensive. One possibility is to calculate the larges model (with all parameters) and let the
      #		calculating function pick out only those parameters they are interested in (the senPars)
      # to do3: evalues are calculated retrospective
      # to do4: correlation is not right, when one pick several parameters => I need a routine, that select the corresponging
      #		columns from the whole sens matrix.
      # to do5: something works different for Degenring2 => is allright, it just stops earlier, when the remaining e-value is
      #		not small enough (at the moment hard coded with 0.001):
      ##################################################################################################################
      ReduceModelOpt:= proc(aDAESys::DAESys,
        DDASPKsenRepeats::integer,
	endTime::numeric,
	startTime::numeric,
	interval::numeric,
	initVars::list(numeric),
	senPars::list(name),
	outputFnctList::list(equation),
	reductionModus::{string, [string, numeric], list(list(name))}, 
	threshold::numeric,
	calcPrecision::integer,
	dirName::string,
	scaled::boolean
	#optional input: inputFct::list([numeric,numeric])
      )

      	local varsList,matrixDimension, nrRowsGMatrix, correlationThreshold, correlationFlag, actCorrelationMatrix, 
	  maxCorrelationPositionAndValue, correlationValue ,ODESolSen, listOfModi, eValue, listOfRemovedParameter, 
	  inputFct, errorList, errorMsg, DDASPKproc, eigenvalues, allEigenvectors, smallestEigenvalueAndPosition, 
	  listOfSmallestEValues, eigenvectorWithSmallestEigenvalue,maxEntryAndPosition, actPosition, gMatrix, 
	  parameterCorrelationMatrix, i, j, actCorrelation, sumOfRows, paramToRemove,toReturn, actSenPars,
	  iterationCounter, hessianMatrix, actHessian, eigenvectorsAndEigenvaluesOfHessian, positionOfSmallestEigenvector,
	  smallestEigenvector, reductionList, sortedEigenvectorsAndEigenvalues, allSortedEigenvectors, 
	  sortedEigenvalues, allSortedEigenvectorsMatrix, degenringList, degenringIndexList, 
	  scalingFactor, actParam, h, actItem,actItemList, actEigenvalue, m, actEigenvector, degenringOpt, 
	  initTime, listOfMaxEigenvectorEntries, actList, st, spendTime,listOfResults, removedParam, tmpResult ;


	initTime:=time();  
	#
	#set precision
	#
	Digits:=calcPrecision;
	#------------------------------------------------------------------------------------	
	#
	#define important variables
	#
	#------------------------------------------------------------------------------------					
	listOfModi:= ["correlation", "eigenvalue", "random", "Degenring1","Degenring2","Degenring3"];
	eValue:=0;
	listOfSmallestEValues:=[];
	listOfRemovedParameter:=[];
	listOfMaxEigenvectorEntries:=[];
	varsList:= aDAESys[DynVars];

  	#------------------------------------------------------------------------------------	
	#
	#check if the directory tmpSysIdentStore already exist, if not create one, if so throw an error
	#
	#------------------------------------------------------------------------------------
	if
	  ModelPack:-DirExists(dirName)
	then
	  error("temporary directory %1 needed to run the procedure ReduceModel already exists. Please rename.", dirName)
	else  
          mkdir(dirName)
	end if:

	DDASPKproc := DDASPKSen:-CreateInstance(aDAESys, dirName, senPars, 'adifor'):

        #-------------------------------------------------------------------------------------------
	#
	#check if optional parameter is used, and has the right format, check additional conditions
	#
	#-------------------------------------------------------------------------------------------
	if
	  (nargs = 14)
	then
	  inputFct :=  args[14];
	  errorList :=  listOfErrorsInInputList( aDAESys, startTime, inputFct);
	  if not
	    errorList=[]
	  then
	    errorMsg :=  convert(errorList, string);
	    error(errorMsg);
	  end if:

	else
	  inputFct := [];
	end if:


	#------------------------------------------------------------------------------------	
	#
	#determine which reduction modus is used
	#
	#------------------------------------------------------------------------------------					
	if
	  type(reductionModus,string)
	then  
	  if not
	    reductionModus in listOfModi
	  then
	    ERROR("The 9th parameter: %1 , has to be element of [%2]",
	      reductionModus,listOfModi);
	  end if:
	else
	  if not
	    ((reductionModus[1]="correlation") or hastype(reductionModus,list(list(name))))
	  then  
	    ERROR("The 9th parameter: %1 , has to be element of the form [correlation, numeric] or list(list(name))",
	      reductionModus);
	  end if:    
	end if:    


	#------------------------------------------------------------------------------------	
	#
	#calculate ODESolSen for the aDAESys from the input with senPars as Sensitivity Parameters
	#
	#------------------------------------------------------------------------------------	
	#
	#check if variable input is used
	#
	if
	  inputFct=[]
	then
	  #
	  #without variable input
	  #
	 ODESolSen :=  CreateODESolSen(DDASPKproc,
	   DDASPKsenRepeats,
	   endTime ,
	   interval,
	   startTime,
	   initVars,
	   scaled
	 ):
	else
	  #
	  #with variable input
	  #
	  ODESolSen :=  CreateODESolSen(DDASPKproc,
	    DDASPKsenRepeats,
	    endTime ,
	    interval,
	    startTime,
	    initVars,
	    scaled,
	    inputFct
	  );

	end if:

	#------------------------------------------------------------------------------------		
	#
	#initialize the parameter correlation matrix once for all parameters
	#
	#------------------------------------------------------------------------------------	
	if
	  reductionModus="correlation" or reductionModus[1]="correlation"
	then
	  gMatrix:= CalculateGMatrix(DDASPKproc,
            ODESolSen,
            startTime,	
	    endTime,
	    varsList,
	    senPars,
            outputFnctList
	  );
	  matrixDimension:=LinearAlgebra[Dimension](gMatrix);
	  nrRowsGMatrix:= matrixDimension[2];

	  #
	  #calculate the correlation Matrix of matrix G see Zak 2003 page 2403 right column bottom and the correlation matrix of the parameter.
	  #parameterCorrelationMatrix can be reused in later reduction steps, only the corresponding rows and columns have to be deleted

	  parameterCorrelationMatrix:= Statistics[CorrelationMatrix](gMatrix, ignore = true);

	  #
	  #process the matrix, and exchange undefined values (happens when one column only has zeros or when the standarddeviation is zero) with zero
	  #
	  for i from 1 to nops(senPars) do:
	    for j from 1 to nops(senPars) do:
	      actCorrelation:= parameterCorrelationMatrix[i,j];
	      if
	        type(actCorrelation, undefined)
	      then
	        parameterCorrelationMatrix[i,j]:=0;
	      end if:
	    end do:
	  end do:

	  
	  #
	  #determine the correlation threshold, if demanded by input parameter
	  #
	  if 
	    hastype(reductionModus[2],float)
	  then
	    correlationThreshold:=reductionModus[2];
	  end if:
	end if:

	#------------------------------------------------------------------------------------		
	#
	#initialize the hessian once for all parameters
	#
	#------------------------------------------------------------------------------------	
        hessianMatrix :=  CreateHessianForSelectedParameters(ODESolSen,
	  varsList,
	  senPars,
	  startTime,
	  endTime,
	  outputFnctList
        );

	#------------------------------------------------------------------------------------		
	#
	#if "list" mode is used, check, that the elements in each list correlate to sensitivity
	#Parameters (specified in senPars)
	#
	#------------------------------------------------------------------------------------	

	if
	  hastype(reductionModus,list(list(name)))
	then
	  for actList in reductionModus do:	
	    # 
	    #test if all parameters specified in the list are also contained in senPar
	    #
	    if not
	      convert(actList,set) subset convert(senPars,set)
	    then
	      ERROR("The 9th parameter: %1 , has to be a subset of %2", actList, senPars);
	    end if:
	  end do:  

	end if:

	#------------------------------------------------------------------------------------	
	#
	#while-loop, that reduces the model stepwise
	#
	#------------------------------------------------------------------------------------						
	actSenPars:= senPars:
	iterationCounter:=0;
	#positionListForCorrelation:=[];
	actPosition:=0;
	correlationFlag:=false;
	actHessian:=hessianMatrix;
	initTime:= time()- initTime;
	print("initialization finished: time needed: ", initTime); 
	#------------------------------------------------------------------------------------						
	#
	#if not list mode is used
	#
	#------------------------------------------------------------------------------------						
	if not
	  hastype(reductionModus,list(list(name)))
	then
	  while (eValue < threshold) do:
	    print("iteration", iterationCounter);

	    #
	    #Eigenvectors returns a tupel of first a column vector containing the eigenvalues and then a matrix, where each column represents the
	    #Eigenvector
	    #
	    st:=time();
	    eigenvectorsAndEigenvaluesOfHessian :=  [linalg[eigenvectors](actHessian)];
	    spendTime:= time()-st;
	    print("EigenvectorCalculation finished after: ", spendTime);
	    eigenvalues:= convert([seq(eigenvectorsAndEigenvaluesOfHessian[i][1],i=1..nops(eigenvectorsAndEigenvaluesOfHessian))],
	      Vector
	    );

	    #
	    #determine the smallest eigenvalue (the LinearAlgebara[Eigenvectors] methods returns them already sorted
	    #
	    smallestEigenvalueAndPosition:= FindMinAbsInVector(eigenvalues,1);
	    eValue:=smallestEigenvalueAndPosition[1][1];
	    listOfSmallestEValues:=[op(listOfSmallestEValues), eValue];##
	    positionOfSmallestEigenvector:= smallestEigenvalueAndPosition[1][2];
	    allEigenvectors:=[seq(op(eigenvectorsAndEigenvaluesOfHessian[i][3]),  
	      i=1..nops(eigenvectorsAndEigenvaluesOfHessian)
	    )];
	    smallestEigenvector:= convert(allEigenvectors[positionOfSmallestEigenvector],Vector);

	    #------------------------------------------------------------------------------------	
	    #
	    #do reduction step
	    #
	    #------------------------------------------------------------------------------------

	    #------------------------------------------------------------------------------------	  
	    #
	    #
	    #if "eigenvalue" is the reduction modus:
	    #
	    #
	    #we use the eigenvector with smalles eigenvalue to decide which
	    #parameter is removed. That parameter corresponding to the largest absolute entry in that eigenvector is
	    #is chosen to be removed.
	    #
	    #------------------------------------------------------------------------------------
	    if
	      reductionModus="eigenvalue"
	    then
	     #eigenvectorWithSmallestEigenvalue:= LinearAlgebra[Column](eigenvectors,smallestEigenvalueAndPosition[2]):
	      maxEntryAndPosition:=op(SysIdent:-FindMaxAbsInVector(smallestEigenvector,3));  #returns [[value, position]...[value,position]]
	      actPosition:=maxEntryAndPosition[1][2];
	      print(senPars[actPosition],seq(maxEntryAndPosition[i][2], i=1..nops([maxEntryAndPosition])));
	      listOfMaxEigenvectorEntries:=[op(listOfMaxEigenvectorEntries), maxEntryAndPosition[1]];
	      

	    #------------------------------------------------------------------------------------
	    #
	    #reduction is decided via the "correlation" matrix introduced by Jacques and Greif 1985, and also described in Zak et al. 2003.
	    #To decide which parameter is the highest correlated parameter, here the sum of all absolute corelations of one vector to all others is
	    #calculated (sum over one row of the correlation matrix) and that parameter with the highes sum will be removed.
	    #Alternative only those values of a row, that are sufficient (defined by threshold) close to 1 are summed up.
	    #
	    #------------------------------------------------------------------------------------
	    elif
	      reductionModus="correlation" or reductionModus[1]="correlation"  
	    then

	      #
	      #select the right columns (corresponding to the reduced parameter set) out of the correlation Matrix
	      #
	      if
		actPosition=0
	      then
		actCorrelationMatrix:= parameterCorrelationMatrix;
	      else

		#
		#delete those rows and columns of the correlation Matrix, corresponding to removed parameters 
		#
		actCorrelationMatrix:=LinearAlgebra[DeleteColumn](actCorrelationMatrix,actPosition);
		actCorrelationMatrix:=LinearAlgebra[DeleteRow](actCorrelationMatrix,actPosition);
	      end if:

	      #
	      #select that parameter with highest absolute Correlation sum, differentiate between both possible modi
	      #
	      if
		type(reductionModus,string)
	      #
	      #either sum over all row elements
	      #
	      then
		sumOfRows:= SysIdent:-CalculateAbsoluteSumOfRow(actCorrelationMatrix);
		actPosition:= SysIdent:-FindMaxAbsInVector(sumOfRows, 1)[1][2]; #FindMaxAbsInVector returns list[[value, position]]

	      #
	      #or sum over row elements > a threshold
	      #
	      else
		sumOfRows:= SysIdent:-CalculateSumOfSelectedValuesPerRow(actCorrelationMatrix, correlationThreshold);

	      end if:
	      maxCorrelationPositionAndValue:= SysIdent:-FindMaxAbsInVector(sumOfRows, 1)[1]; #FindMaxAbsInVector returns list[[value, position]]
	      actPosition:= maxCorrelationPositionAndValue[2];
	      correlationValue:= maxCorrelationPositionAndValue[1];

	      #
	      #lower the correlation value until a new Parameter is found with sum of correlation values !=0 for reduction
	      #
	      while (correlationValue=1 and correlationThreshold>0) do:
		correlationThreshold:= correlationThreshold-0.01;
		sumOfRows:= SysIdent:-CalculateSumOfSelectedValuesPerRow(actCorrelationMatrix, correlationThreshold);
		maxCorrelationPositionAndValue:= SysIdent:-FindMaxAbsInVector(sumOfRows, 1)[1]; #FindMaxAbsInVector returns list[[value, position]]
		actPosition:= maxCorrelationPositionAndValue[2];
		correlationValue:= maxCorrelationPositionAndValue[1];
		correlationFlag:=true; 
	      end do:
	    #------------------------------------------------------------------------------------
	    #
	    #remove parameter randomized
	    #
	    #------------------------------------------------------------------------------------
	    elif
	      reductionModus="random"
	    then
	      actPosition:= rand(1..nops(actSenPars))

	    #------------------------------------------------------------------------------------		
	    #
	    #if "Degenring" mode is used
	    #
	    #------------------------------------------------------------------------------------	
	    elif
	      reductionModus in {"Degenring1", "Degenring2", "Degenring3"}
	    then
	      #
	      #if we are in the first iteration, calculate the list of parameters selected by the Degenring method
	      #
	      if
		iterationCounter=0
	      then
		#
		#create a matrix of all sorted eigenvectors
		#
		sortedEigenvectorsAndEigenvalues:= sort( eigenvectorsAndEigenvaluesOfHessian, firstListNumericElementIsSmaller);

		allSortedEigenvectors:=[];
		sortedEigenvalues:=[];
		for h from 1 to nops(sortedEigenvectorsAndEigenvalues) do
		  actItem:= sortedEigenvectorsAndEigenvalues[h][3];
		  actEigenvalue:=sortedEigenvectorsAndEigenvalues[h][1];
		  if
		    nops(actItem)=1  
		  then		   
		    allSortedEigenvectors:= [op(allSortedEigenvectors),convert(op(actItem),list)];
		    sortedEigenvalues:= [op(sortedEigenvalues), actEigenvalue];
		  else
		    #
		    #insert the multiple eigenvectors seperatly into the list allSortedEigenvectorsAndEigenvalues;
		    #attention: eigenvectors with the same eigenvalues are not in an kanonic order => we have to order
		    #
		    actItemList:=[];
		    #
		    #convert all eigenvectros to list
		    #
		    for m from 1 to nops(actItem) do:
		      actEigenvector:=actItem[m];
		      actItemList:=[op(actItemList), convert(actEigenvector,list)];
  #		    allSortedEigenvectors:=[op(allSortedEigenvectors),convert(op(actEigenvector),list)];
		      sortedEigenvalues:=[op(sortedEigenvalues), actEigenvalue];
		    end do:
		    actItemList:=sort(actItemList, ListNumericIsLarger);
		    allSortedEigenvectors:=[op(allSortedEigenvectors), op(actItemList)];
		  end if:

		end do:
  #	      allSortedEigenvectors:=[seq(convert(op(sortedEigenvectorsAndEigenvalues[i][3]),list),  
  #	        i=1..nops(eigenvectorsAndEigenvaluesOfHessian)
  #	      )];
  #	      sortedEigenvalues:= convert([seq(sortedEigenvectorsAndEigenvalues[i][1],i=1..nops(sortedEigenvectorsAndEigenvalues))],
  #	        Vector
  #	      );
		sortedEigenvalues:= convert(sortedEigenvalues, Vector);
		print("sortedEigenvalues", sortedEigenvalues);
		allSortedEigenvectorsMatrix:= convert(allSortedEigenvectors,Matrix);
		allSortedEigenvectorsMatrix:= LinearAlgebra[Transpose](allSortedEigenvectorsMatrix);

		#
		#set options for the Degenring parameter selection
		#
		degenringOpt:=["threshold",threshold];

		#
		#select the corresponding Degenring method 1,2 or 3
		#
		if
		  reductionModus="Degenring1"
		then
		  degenringList:=FindDegenringParameters(allSortedEigenvectorsMatrix,
		    sortedEigenvalues,
		    senPars,
		    1,
		    degenringOpt
		  );
		elif
		  reductionModus="Degenring2"
		then
		  degenringList:=FindDegenringParameters(allSortedEigenvectorsMatrix,
		    sortedEigenvalues,
		    senPars,
		    2,
		    degenringOpt
		  );
		else
		  degenringList:=FindDegenringParameters(allSortedEigenvectorsMatrix,
		    sortedEigenvalues,
		    senPars,
		    3,
		    degenringOpt
		  );
		end if:
	      end if:
	      if
		degenringList=[]
	      #
	      #break if all parameters from the list are removed
	      #
	      then
		break;
	      else
		actPosition:=op(FindIndicesOfListElements([degenringList[1]], actSenPars));
		degenringList:=degenringList[2..nops(degenringList)];
	      end if:

	    end if:


	    #
	    #add the removed parameter to the corresponding list for the output
	    #
	    paramToRemove:= actSenPars[actPosition];

	    #
	    #check wether the correlationFlag is hissed
	    #
	    if
	      correlationFlag
	    then
	      paramToRemove:=[paramToRemove,correlationThreshold];
	    end if:

	    listOfRemovedParameter:=[op(listOfRemovedParameter), paramToRemove];

	    #
	    #actualize the hessian, by deleting the row and column corresponding to the removed paramter
	    #
	    actHessian:=LinearAlgebra[DeleteColumn](actHessian,actPosition);
	    actHessian:=LinearAlgebra[DeleteRow](actHessian,actPosition);
	    actHessian:=Matrix(actHessian,shape=symmetric);

	    #
	    #remove the parameter from the senPars list
	    #
	    actSenPars:=[op(actSenPars[1..(actPosition-1)]),
	      op(actSenPars[(actPosition+1)..-1]
	    )];

	    iterationCounter:= iterationCounter + 1;

	  end do:
	  toReturn:=[listOfRemovedParameter, listOfSmallestEValues, actHessian,listOfMaxEigenvectorEntries,parameterCorrelationMatrix ];

	#------------------------------------------------------------------------------------		
	#
	#if "list" mode is used
	#
	#------------------------------------------------------------------------------------	
	else
	  listOfResults:=[];
	  toReturn:=[];
	  for h from 1 to nops(reductionModus) do:
            actList:=reductionModus[h];
	    print("progress ",h);
	    reductionList:=actList;
	    actHessian:=hessianMatrix;
	    actSenPars:= senPars:
	    listOfSmallestEValues:=[];
	    removedParam:=[];
	    for i from 1 to nops(actList) do:
	      #
	      #Eigenvectors returns a tupel of first a column vector containing the eigenvalues and then a matrix, where each column represents the
	      #Eigenvector
	      #
	      print("Eigenvector Calculation started");
	      #DEBUG();
	      st:=time();
	      eigenvectorsAndEigenvaluesOfHessian :=  [linalg[eigenvectors](actHessian)];
	      spendTime:= time()-st;
	      print("EigenvectorCalculation finished after: ", spendTime);
	      eigenvalues:= convert([seq(eigenvectorsAndEigenvaluesOfHessian[i][1],i=1..nops(eigenvectorsAndEigenvaluesOfHessian))],
	        Vector
	      );

	      #
	      #determine the smallest eigenvalue (the LinearAlgebara[Eigenvectors] methods returns them already sorted
	      #
	      smallestEigenvalueAndPosition:= FindMinAbsInVector(eigenvalues,1);
	      eValue:=smallestEigenvalueAndPosition[1][1];

	      #
	      #test the threshold criterion and if neccesarry break the calculation
	      #
	      if
	        eValue >= threshold
	      then
	        break;
	      end if:
	      
	      listOfSmallestEValues:=[op(listOfSmallestEValues), eValue];##
	      positionOfSmallestEigenvector:= smallestEigenvalueAndPosition[1][2];
	      allEigenvectors:=[seq(op(eigenvectorsAndEigenvaluesOfHessian[i][3]),  
	        i=1..nops(eigenvectorsAndEigenvaluesOfHessian)
	      )];
	      smallestEigenvector:= convert(allEigenvectors[positionOfSmallestEigenvector],Vector);

	      actParam:=reductionList[1];
	      removedParam:=[op(removedParam),actParam];
	      reductionList:=reductionList[2..nops(reductionList)];
	      actPosition:= op(FindIndicesOfListElements([actParam], actSenPars));

	      #
	      #actualize the hessian, by deleting the row and column corresponding to the removed paramter
	      #
	      actHessian:=LinearAlgebra[DeleteColumn](actHessian,actPosition);
	      actHessian:=LinearAlgebra[DeleteRow](actHessian,actPosition);
	      actHessian:=Matrix(actHessian,shape=symmetric);

	      #
	      #remove the parameter from the senPars list
	      #
	      actSenPars:=[op(actSenPars[1..(actPosition-1)]),
	        op(actSenPars[(actPosition+1)..-1]
	      )];
	    end do:
	    tmpResult:= [actList, removedParam, listOfSmallestEValues, actHessian];
	    toReturn:=[op(toReturn), tmpResult];
	  end do:
	end if:

	return toReturn;
      end proc:


      ##################################################################################################################
      # input: DDASPKproc -> module of type DDASPKSen
      #	       trajeSens -> module of type Curve, has to be created with function CreateODESolSen
      #        endTime -> right border of integration
      #        startTime -> left border of integration
      #        varsList -> contains the names of the dynamic variables;
      #        senParsList -> contains the names of the sensitivity parameters; 
      #        outputFnctList-> list of equations, containing the response functions (g(x(t),p,u(t)))
      #
      #
      # output:  gMatrix -> the matrix of Sensitivities of the outputs regarding the parameters, see reference
      # reference: "Importance of Input Pertubations and Stochastic Gene Expression in the Reverse Engineering of Genetik
      #		   Regulatory Networks: Insights From an Identifiability Analysis of an In Silico Network", Zak 2003
      # toDo: tested with an analytical solution U:/reposit/maple/SysIdent/trunk/CorrelationTest/simpleExp1-correlationTestOpt.mws
      #	      has to be tested for the case, where the response functions are functions of the parameters. In the simple test
      #	      the outputs correspond to the dynamic variables => the chain rule for differentiation is not applyied
      ##################################################################################################################
      CalculateGMatrix:= proc(DDASPKproc::`module`,
        trajeSens::`module`,
        startTime::numeric,	
	endTime::numeric,
	varsList::list(name),
	senParsList::list(name),
        outputFnctList::list(equation)
      )
      
        local errList,rowCounter, endTimeOfSolution, listOfErrors, errMsg, data, sizeTrajeSens, actDAESys, nrVars, nrParams, nrFnct, initTime,
	  timePoints, actStartPosition, actEndPosition, startFlag, f, actItem, nrRowsOfG, nrColumnsOfG, matrixG, jakobianPars, jakobianVars,
	  i, VarsEqu, nrTimePoints, tmp, loopVars, subsList, j, l, actParam, sumOverVarsL, actJakobianParsL, m, actState, actSensNameL,
	  actSensValueL, actJakobianVars, dgJdParamL, gMatrix, correlationMatrix ;


	#------------------------------------------------------------------------------------	
	#
	#define important variables
	#
	#------------------------------------------------------------------------------------	

	#
	#check if trajeSens is a result of CreateODESolSen. For each variable x from varsList and for each parameter p from
	#paramList there must be one sensitivity name of the format dxdp as table index in trajeSens. Furthermore all
	#variables from varsList must be index in trajeSens.
	#
	errList:= CurveContainsVarsAndSensOfParams(trajeSens, varsList, senParsList);
	if  not
	  errList=[]
	then
	  ERROR(convert(errList, string));
	end:

	data:= trajeSens:-GetData();
	sizeTrajeSens:=trajeSens:-GetNumPoints();
	actDAESys := DDASPKproc:-GetSys();
	nrVars := nops(varsList);
	nrParams:= nops(senParsList);
	nrFnct := nops(outputFnctList);
	initTime:= data[time][1];

	#------------------------------------------------------------------------------------	
	#
	#check if arguments are correct
	#
	#------------------------------------------------------------------------------------	

	#
	#check if last timepoint in trajeSens at least equals the parameter endTime
	#
	endTimeOfSolution:= data[time][sizeTrajeSens];
	if
	  endTimeOfSolution < endTime
	then
	  error("#of datapoints in second parameter has to be larger than fifth parameter"); 
	end if:

	#
	#check wether the outputFnctList has the right format (see also documentation of listOfErrorsInOutputFunctions)
	#
	listOfErrors := listOfErrorsInOutputFunctions(senParsList,
	  varsList,
	  outputFnctList
	);

	#
	#if there has been an error, throw an exception with the corresponding message
	#
	if not
	  listOfErrors=[]
	then
	  errMsg:=convert(listOfErrors,string);
	  error errMsg;
	end if:

	#
	#check if startTime is larger than initTime. startTime can only be larger than the initTime
	#
	if
	  startTime < initTime
	then
	  error("second parameter has to be larger then the fifth");
	end if:


	#------------------------------------------------------------------------------------	
	#
	#Get trajectories and sensitivities and create Jakobian
	#
	#------------------------------------------------------------------------------------	

	#
	#Get the number of points in trajeSens
	#
	timePoints:=trajeSens:-GetNumPoints();

	#
	#determine at which position in data[time] startTime and endTime is reached
	#
	actStartPosition:= 0;
	actEndPosition:=0;
	startFlag:=false:
	actStartPosition:=1;
	for f from 1 to timePoints do:
	  actItem:= data[time][f];
	  if
	    (actItem>= startTime and not startFlag)
	  then
	    actStartPosition:=f;
	    startFlag:= true;
	  elif
	    (actItem>= endTime)
	  then
	    actEndPosition:= f;
	    break;
	  end if:
	end do:

	#
	#Initialize g Matrix (corresponds to the Jacobian matrices of the response functions, regarding the parameters at all sampling
	#times) => dimension of the matrix is: rows = number of response function times number of sampling times, 
	#
	nrRowsOfG:= nrFnct*timePoints;
	nrColumnsOfG:= nrParams;
	matrixG:=Matrix(1..nrRowsOfG, 1..nrColumnsOfG, 99);

	#
	#create Jakobian regarding the Parameters and regarding the variables
	#
	jakobianPars := linalg[jacobian](map(rhs, outputFnctList),senParsList);
	jakobianVars := linalg[jacobian](map(rhs, outputFnctList),varsList);

	#------------------------------------------------------------------------------------	
	#
	#fill matrix G
	#
	#------------------------------------------------------------------------------------

	rowCounter:=0;
	#
	#iterate over each sample (see Zak 2003 paper) 
	#
	for i from actStartPosition to actEndPosition do:

	  #
	  #VarsEqu saves the Values for the dynamic Variables at time i
	  #
	  VarsEqu:=array(1..nrVars);
	  nrTimePoints:= actEndPosition-actStartPosition +1:

	  #
	  #fill VarsEqu with equations: state=value, for substitution in the last loop (loop over state variables).
	  #
	  for tmp from 1 to nrVars do:
	    loopVars:= varsList[tmp]:
	    VarsEqu[tmp]:=loopVars=data[loopVars][i]:
	  end do:

	  #
	  #create subsList, for substitution in the last loop (loop over state variables) 
	  #
	  VarsEqu:=convert(VarsEqu, list):
	  subsList:=[op(VarsEqu),op(actDAESys[SenPars])]:

	  #
	  #iterate over all response function => here one starts to create the submatrices SyTi (nomenclatur Zak 2003)
	  #
	  for j from 1 to nrFnct do:

	    #
	    #count the number of rows
	    #
	    rowCounter:= rowCounter +1;	

	    #
	    #iterate over all parameters => here one fill  one row of the g Matrix
	    #
	    for l from 1 to nrParams do:

	      actParam:= senParsList[l];
	      sumOverVarsL:= 0;
	      actJakobianParsL:= jakobianPars[j,l];

	      #
	      #Sum over statevariables, here subsList is needed
	      #
	      for m from 1 to nrVars do:
		actState:= varsList[m];
		actSensNameL := cat('d',actState,'d',actParam);	#create names ('dxdp') serving as indices for data table
		actSensValueL := data[actSensNameL][i];
		actJakobianVars := jakobianVars[j,m];

		#
		#calculate dg/dp's for fixed timePoint and fixed response function
		#
		sumOverVarsL := sumOverVarsL +subs(subsList,actJakobianVars)*actSensValueL;
	      end do:

	      #
	      #add single term to the previous calculated sumOverVars
	      #
	      dgJdParamL := sumOverVarsL + subs(subsList,actJakobianParsL);

	      #
	      #fill dgJdParamL into the correct position of matrix G
	      #

	      matrixG[rowCounter,l]:= dgJdParamL;

	    end do:

	  end do

	end do:
	return matrixG;

      end proc:


      ##################################################################################################################
      # input: elements -> list of elements to check the indexes for, all elements have to be unique in this list
      #	       referenceList	-> reference list, contains all elements, at the right position, all elements have to
      #				   be unique
      #        
      # output: list of indices
      ##################################################################################################################
      FindIndicesOfListElements:= proc(elements::list,
        referenceList::list)

	local indexTable, keyEntryList, indexList, actElement, repetitionList1, repetitionList2;

	repetitionList1:= ListTools[FindRepetitions](referenceList);
	repetitionList2:= ListTools[FindRepetitions](elements);

	#
	#referenceList has to contain only unique elements
	#
	if not
	  repetitionList1=[]
	then
	  error("in the second parameter: %1, the elements %2 occur several times.", referenceList, repetitionList1);
	#
	#elements has to contain only unique elements
	#
	elif not  
	  repetitionList2=[]
	then
	  error("In the first parameter: %1, the elements %2 occur several times.", elements, repetitionList2);
	
	#
	#check if elements is a subset of referenceList, if not throw an error
	#
	elif not
	  convert(elements,set) subset convert(referenceList,set)
	then
	  error("The 1th parameter: %1 , has to be a subset of %2", list, referenceList);

	#
	#everthing alright with the inputs
	#
	else
	  #
	  #create a table containing: keywords are the parameters, and entries are the indices
	  #
	  keyEntryList:= [seq(referenceList[i]=i,i=1..nops(referenceList))];
	  indexTable:= table(keyEntryList);

	  #
	  #find all indices
	  #
	  indexList:=[];
	  for actElement in elements do:
	    indexList:=[op(indexList), indexTable[actElement]];
	  end do:
	end if:

	return indexList;

      end proc:

      ##################################################################################################################
      # input: eigenvectorMatrix -> real matrix, each column contains an eigenvector, the first column represents,
      #				    the eigenvector with smallest eigenvalue, the second column represents the
      #				    eigenvector with second smallest eigenvalue and so on...
      #	       eigenvalues -> eigenvalues (sorted), corresponding to the eigenvectors in the eigenvectorMatrix		    
      #	       parameterList -> list of parameterNames corresponding to the eigenvector Matrix, dimension has to match the
      #				the eigenvectorMatrix dimension
      #	       mode -> 1,2 and 3, correspond to the different modes described in Degenring 2004, pp 375, section 3.3
      #	       selsectOptions -> [name,numeric], name can be "threshold" (>0) => the following numeric values,
      #				 describes a threshold; if the eigenvalue is larger
      #				 then threshold  the selection of parameters is stopped. If name is "number" => the following integer sets the number of
      #				 parameters that should be removed. 
      # output: list of parameters to remove; criterions for removal are taken from Degenring 2004
      ##################################################################################################################
      FindDegenringParameters:= proc(eigenvectorMatrix::Matrix,
        eigenvalues::Vector,
        parameterList::list(name),
	mode::integer,
	selectOptions::[string,numeric]
      )

	local nrParams, matrixDimension, actParam, i, actEigenvector, actEigenvectorMatrix, removalList, actParToRemove, thresholdIterator,
	  maxAbsResult, actRemovalIndex,k, actValues, j, actRowDimension, mode3Vector,actRow,sortedMaxResults,nrEigenvalues, actParameterList,
	  legalOptionNames, optionName, optionValue, threshold;

	nrParams:=nops(parameterList);
	matrixDimension:= op(1,eigenvectorMatrix)[1];
	removalList:=[];
	actParameterList:=parameterList;
	legalOptionNames:={"threshold", "number"};
	optionName:=selectOptions[1];
	optionValue:=selectOptions[2];

	#--------------------------------------------------------------------------------
	#
	#check the input parameters
	#
	#--------------------------------------------------------------------------------

	#
	#check if optionName is element of legalOptionNames
	#
	if not
	  optionName in legalOptionNames
	then
	  error("the name of the tupel of the fifth parameter: %1, has to be from %2", optionName, legalOptionNames);
	end if:

	#
	#check if the numeric values of the option tupel are valid 
	#
	if
	  optionName="threshold"	
	then			
	  if
	    optionValue<0
	  then	
	    error("the value of the tupel of the fifth parameter: %1, has to be larger than 0",optionValue);
	  end if:
	elif
	  optionName="number"
	then
	  if not
	    hastype(optionValue,posint)
	  then
	    error("the value of the tupel of the fifth parameter: %1, has to be a positive integer", optionValue);
	  elif
	    optionValue>nrParams
	  then	
	    error("the value of the tupel of the fifth parameter: %1, has to be a <= the number of parameters: %2, in the third parameter",
	      optionValue, nrParams)
	  end if:
	end if:

	#
	#check if the dimensions of the eigenvectorMatrix corresponds to the dimension of nrParams
	#
	if not
	  nrParams=matrixDimension
	then
	  error("Dimension of first parameter: %1, and the third parameter: %2, do not match",matrixDimension, nrParams);
	end if;

	#
	#check if the dimensions of the eigenvectorMatrix corresponds to the dimension of eigenvalues
	#
	nrEigenvalues:=LinearAlgebra[Dimension](eigenvalues);
	if not
	  matrixDimension=nrEigenvalues
	then
	  error("Dimension of first parameter: %1, and second parameter %2, do not match",matrixDimension, nrEigenvalues);
	end if;

	#
	#check if eigenvalues is ordered
	#
	if not
	  ListTools[Sorted](convert(eigenvalues,list))
	then
	  error("The second parameter: %1, has to be a sorted vector.",eigenvalues);
	end if:  
	  
	#
	#check if mode is element {1,2,3}
	#
	if not
	  mode in {1,2,3}
	then
	  error("The mode parameter: %1, has to be element of the set {1,2,3}",mode);
	end if:

	#--------------------------------------------------------------------------------
	#
	#select the parameters from parameterList, in the order as they should be removed
	#
	#--------------------------------------------------------------------------------
	actEigenvectorMatrix:=eigenvectorMatrix;
	if
	  mode =1 or mode=3
	then
	  for i from 1 to nrParams do:
	    if
	      mode = 1
	    then
	      actEigenvector:= LinearAlgebra[Column](actEigenvectorMatrix,i);	  

	    elif
	      mode=3
	    then
	      actEigenvector:= LinearAlgebra[Column](actEigenvectorMatrix,-i);	  	    	      
	     end if:

	    maxAbsResult:=FindMaxAbsInVector(actEigenvector,1);    #FindMaxAbsInVector returns list[[value, position]]
	    actRemovalIndex:= maxAbsResult[1][2];
	    actParToRemove:=actParameterList[actRemovalIndex];
	    actParameterList:=subsop(actRemovalIndex = NULL,actParameterList);
	    removalList:=[op(removalList),actParToRemove];

	    #remove the corresponding row from the actEigenvector for the next round
	    actEigenvectorMatrix:=LinearAlgebra[DeleteRow](actEigenvectorMatrix, actRemovalIndex);
	  end do:
        end if:  

	#
	#if mode 3 is selected we have to switch the ranking order, because mode 3 implements
	#a positive selection
	#
	if
	  mode = 3
	then
	  removalList:=ListTools[Reverse](removalList);
	end if;

	#
	#check for the options and adapt the removal List correspondingly
	#
	
	if
	  optionName="threshold"
	then
	  threshold:=optionValue;
	  #
	  #determine which eigenvectors are still small, keep in mind eigenvalues is a sorted list (ascending)
	  #
	  thresholdIterator:=0;

	  if not
	    threshold = 0
	  then
	    for k from 1 to nrParams do:
	      actValues:=eigenvalues[k];
	      if
		actValues>threshold
	      then
		thresholdIterator:= k;
		break;
	      end if:
	    end do:
	    thresholdIterator:=thresholdIterator-1;
	  end if: 

	  #
	  #if no value is below the threshold, throw an error
	  #
	  if
	    thresholdIterator=0
	  then
	    error("No Value in %1 is below %2.", convert(eigenvalues,list), threshold);
	  #
	  #if no threshold is chosen or if all values in eigenvalues are below the threshold (here threshold is not set, and therefore -1)
	  #
	  elif
	    thresholdIterator=-1 or threshold=0
	  then
	   if
	     mode=2 
	   then
	     thresholdIterator:=nrParams;
	     actEigenvectorMatrix:=eigenvectorMatrix;
	   #
	   #if mode = 1 or 3
	   #
	   else
	     removalList:= removalList;	   
	   end if:

	  else
	    if
	      mode = 2
	    then
	      actEigenvectorMatrix:=LinearAlgebra[DeleteColumn](eigenvectorMatrix,(thresholdIterator+1)..-1);
	    elif
	      mode = 1 or mode =3
	    then
	      removalList:=removalList[1..thresholdIterator];
	    end if:
	  end if:


	elif
	  optionName="number"
	then
	  if
	    mode = 2
	  then  
	    actEigenvectorMatrix:=LinearAlgebra[DeleteColumn](eigenvectorMatrix,(optionValue+1)..-1);
	    thresholdIterator:=optionValue;
	  elif
	    mode = 3 or mode = 1
	  then
	    removalList:=removalList[1..optionValue];
	  end if:
	end if:

	#
	#if mode is 2, then special processing is neccesary
	#
	if
	  mode = 2
	then
	  #
	  #calculate the squared sum over the rows for each row
	  #
	  actRowDimension:=LinearAlgebra[Dimension](actEigenvectorMatrix)[1];
	  mode3Vector:=Vector[column](actRowDimension);
	  for i from 1 to actRowDimension do:
	    actRow:=LinearAlgebra[Row](actEigenvectorMatrix,i);
	    mode3Vector[i]:= actRow.actRow;      
	  end do:
	  sortedMaxResults:=FindMaxAbsInVector(mode3Vector, op(1,mode3Vector));

	  for j from 1 to thresholdIterator do:
	    actRemovalIndex:=sortedMaxResults[1][2];
	    actParToRemove:=actParameterList[actRemovalIndex];
	    removalList:=[op(removalList), actParToRemove];
	    sortedMaxResults:=subsop(1=NULL, sortedMaxResults);
	  end do:
	end if:	  

	return removalList;

      end proc:

      ##################################################################################################################
      # input: eigenvectorMatrix -> real matrix, each column contains an eigenvector, the first column represents,
      #				    the eigenvector with smallest eigenvalue, the second column represents the
      #				    eigenvector with second smallest eigenvalue and so on...
      #	       eigenvalues -> eigenvalues (sorted), corresponding to the eigenvectors in the eigenvectorMatrix		    
      #	       parameterList -> list of parameterNames corresponding to the eigenvector Matrix, dimension has to match the
      #				the eigenvectorMatrix dimension
      #	       mode -> 1,2 and 3, correspond to the different modes described in Degenring 2004, pp 375, section 3.3
      #	       selsectOptions -> [name,numeric], name can be "threshold" (>0) => the following numeric values,
      #				 describes a threshold; if the eigenvalue is larger
      #				 then threshold  the selection of parameters is stopped. If name is "number" => the following integer sets the number of
      #				 parameters that should be removed. 
      # output: list of parameters to remove; criterions for removal are taken from Degenring 2004
      ##################################################################################################################
      FindDegenringParametersOpt:= proc(eigenvectorMatrix::Matrix,
        eigenvalues::Vector,
        parameterList::list(name),
	mode::integer,
	selectOptions::[string,numeric]
      )

	local nrParams, matrixDimension, actParam, i, actEigenvector, actEigenvectorMatrix, removalList, actParToRemove, thresholdIterator,
	  maxAbsResult, actRemovalIndex,k, actValues, j, actRowDimension, mode3Vector,actRow,sortedMaxResults,nrEigenvalues, actParameterList,
	  legalOptionNames, optionName, optionValue, threshold;

	nrParams:=nops(parameterList);
	matrixDimension:= op(1,eigenvectorMatrix)[1];
	removalList:=[];
	actParameterList:=parameterList;
	legalOptionNames:={"threshold", "number"};
	optionName:=selectOptions[1];
	optionValue:=selectOptions[2];

	#--------------------------------------------------------------------------------
	#
	#check the input parameters
	#
	#--------------------------------------------------------------------------------

	#
	#check if optionName is element of legalOptionNames
	#
	if not
	  optionName in legalOptionNames
	then
	  error("the name of the tupel of the fifth parameter: %1, has to be from %2", optionName, legalOptionNames);
	end if:

	#
	#check if the numeric values of the option tupel are valid 
	#
	if
	  optionName="threshold"	
	then			
	  if
	    optionValue<0
	  then	
	    error("the value of the tupel of the fifth parameter: %1, has to be larger than 0",optionValue);
	  end if:
	elif
	  optionName="number"
	then
	  if not
	    hastype(optionValue,posint)
	  then
	    error("the value of the tupel of the fifth parameter: %1, has to be a positive integer", optionValue);
	  elif
	    optionValue>nrParams
	  then	
	    error("the value of the tupel of the fifth parameter: %1, has to be a <= the number of parameters: %2, in the third parameter",
	      optionValue, nrParams)
	  end if:
	end if:

	#
	#check if the dimensions of the eigenvectorMatrix corresponds to the dimension of nrParams
	#
	if not
	  nrParams=matrixDimension
	then
	  error("Dimension of first parameter: %1, and the third parameter: %2, do not match",matrixDimension, nrParams);
	end if;

	#
	#check if the dimensions of the eigenvectorMatrix corresponds to the dimension of eigenvalues
	#
	nrEigenvalues:=LinearAlgebra[Dimension](eigenvalues);
	if not
	  matrixDimension=nrEigenvalues
	then
	  error("Dimension of first parameter: %1, and second parameter %2, do not match",matrixDimension, nrEigenvalues);
	end if;

	#
	#check if eigenvalues is ordered
	#
	if not
	  ListTools[Sorted](convert(eigenvalues,list))
	then
	  error("The second parameter: %1, has to be a sorted vector.",eigenvalues);
	end if:  
	  
	#
	#check if mode is element {1,2,3}
	#
	if not
	  mode in {1,2,3}
	then
	  error("The mode parameter: %1, has to be element of the set {1,2,3}",mode);
	end if:

	#--------------------------------------------------------------------------------
	#
	#select the parameters from parameterList, in the order as they should be removed
	#
	#--------------------------------------------------------------------------------
	actEigenvectorMatrix:=eigenvectorMatrix;
	if
	  mode =1 or mode=3
	then
	  for i from 1 to nrParams do:
	    if
	      mode = 1
	    then
	      actEigenvector:= LinearAlgebra[Column](actEigenvectorMatrix,i);	  

	    elif
	      mode=3
	    then
	      actEigenvector:= LinearAlgebra[Column](actEigenvectorMatrix,-i);	  	    	      
	     end if:

	    maxAbsResult:=FindMaxAbsInVector(actEigenvector,1);    #FindMaxAbsInVector returns list[[value, position]]
	    actRemovalIndex:= maxAbsResult[1][2];
	    actParToRemove:=actParameterList[actRemovalIndex];
	    actParameterList:=subsop(actRemovalIndex = NULL,actParameterList);
	    removalList:=[op(removalList),actParToRemove];

	    #remove the corresponding row from the actEigenvector for the next round
	    actEigenvectorMatrix:=LinearAlgebra[DeleteRow](actEigenvectorMatrix, actRemovalIndex);
	  end do:
        end if:  

	#
	#if mode 3 is selected we have to switch the ranking order, because mode 3 implements
	#a positive selection
	#
	if
	  mode = 3
	then
	  removalList:=ListTools[Reverse](removalList);
	end if;

	#
	#check for the options and adapt the removal List correspondingly
	#
	
	if
	  optionName="threshold"
	then
	  threshold:=optionValue;
	  #
	  #determine which eigenvectors are still small, keep in mind eigenvalues is a sorted list (ascending)
	  #
	  thresholdIterator:=0;

	  if not
	    threshold = 0
	  then
	    for k from 1 to nrParams do:
	      actValues:=eigenvalues[k];
	      if
		actValues>threshold
	      then
		thresholdIterator:= k;
		break;
	      end if:
	    end do:
	    thresholdIterator:=thresholdIterator-1;
	  end if: 

	  #
	  #if no value is below the threshold, throw an error
	  #
	  if
	    thresholdIterator=0
	  then
	    error("No Value in %1 is below %2.", convert(eigenvalues,list), threshold);
	  #
	  #if no threshold is chosen or if all values in eigenvalues are below the threshold (here threshold is not set, and therefore -1)
	  #
	  elif
	    thresholdIterator=-1 or threshold=0
	  then
	   if
	     mode=2 
	   then
	     thresholdIterator:=nrParams;
	     actEigenvectorMatrix:=eigenvectorMatrix;
	   #
	   #if mode = 1 or 3
	   #
	   else
	     removalList:= removalList;	   
	   end if:

	  else
	    if
	      mode = 2
	    then
	      actEigenvectorMatrix:=LinearAlgebra[DeleteColumn](eigenvectorMatrix,(thresholdIterator+1)..-1);
	    elif
	      mode = 1 or mode =3
	    then
	      removalList:=removalList[1..thresholdIterator];
	    end if:
	  end if:


	elif
	  optionName="number"
	then
	  if
	    mode = 2
	  then  
	    actEigenvectorMatrix:=LinearAlgebra[DeleteColumn](eigenvectorMatrix,(optionValue+1)..-1);
	    thresholdIterator:=optionValue;
	  elif
	    mode = 3 or mode = 1
	  then
	    removalList:=removalList[1..optionValue];
	  end if:
	end if:

	#
	#if mode is 2, then special processing is neccesary
	#
	if
	  mode = 2
	then
	  #
	  #calculate the squared sum over the rows for each row
	  #
	  actRowDimension:=LinearAlgebra[Dimension](actEigenvectorMatrix)[1];
	  mode3Vector:=Vector[column](actRowDimension);
	  for i from 1 to actRowDimension do:
	    actRow:=LinearAlgebra[Row](actEigenvectorMatrix,i);
	    mode3Vector[i]:= actRow.actRow;      
	  end do:
	  sortedMaxResults:=FindMaxAbsInVector(mode3Vector, op(1,mode3Vector));

	  for j from 1 to thresholdIterator do:
	    actRemovalIndex:=sortedMaxResults[1][2];
	    actParToRemove:=actParameterList[actRemovalIndex];
	    removalList:=[op(removalList), actParToRemove];
	    sortedMaxResults:=subsop(1=NULL, sortedMaxResults);
	  end do:
	end if:	  

	return removalList;

      end proc:



      ##################################################################################################################
      # input: aDAESys -> DAE system of interest; has to be of type DAESys
      #	       DDASPKsenRepeats -> Defines the number of integration repetitions for DDASPKsen
      #	       endTime -> right border of integration
      #	       startTime -> left border of integration   
      #	       interval -> disctance between points within the integration interval
      #	       initVars -> list of the Variables at start time -> start values for the variables used to solve the DAESys
      #	       senPars -> list containing the sensitivity parameter
      #	       nrParamToRemove -> a number of parameters that should be removed
      #	       calcPrecicion -> integer that fixes the precision of the calculation via Digit
      #	       dirName -> string that defines, where to store the DDASPKsen instance
      #	       scaled -> if true => scaling is applied to the sensitivities        
      #	       optional parameter -> inputFct, list of changing values of the input function
      # output: list of parameter names to remove
      # comment: here the number of parameters can be set variable;
      #	to do: this version might still contain bucks => use V2 and V3, => remove this version
      #	to do: the option that the trajectories and the sensitivities are computed without scaling is hardcoded
      ##################################################################################################################
      FindParametersWithCompleteDegenringApproachV1:= proc(aDAESys::DAESys,
        DDASPKsenRepeats::integer,
	endTime::numeric,
	startTime::numeric,
	interval::numeric,
	initVars::list(numeric),
	senPars::list(name),
	nrParamToRemove::posint,
	calcPrecision::integer,
	dirName::string,
	scaled::boolean
	#optional input: inputFct::list([numeric,numeric])
      )
	local varsList,nrParams, DDASPKproc, inputFct, errorList, errorMsg, ODESolSen, resultListDegenring1, resultListDegenring2, resultListDegenring3,
	  i,actVars, actOutputList, actHessian, eigenvectorsAndEigenvaluesOfHessian, eigenvalues, sortedEigenvectorsAndEigenvalues,
	  allSortedEigenvectors, sortedEigenvalues, h, actItem, actEigenvalue, m, actEigenvector, actOptions, degenring1List, degenring2List,
	  degenring3List, intersectDegenring1, intersectDegenring2, intersectDegenring3, result, allSortedEigenvectorsMatrix;


	#
	#set precision
	#
	Digits:=calcPrecision;
	#------------------------------------------------------------------------------------	
	#
	#define important variables
	#
	#------------------------------------------------------------------------------------					
	varsList:= aDAESys[DynVars];
	nrParams:=nops(senPars);

  	#------------------------------------------------------------------------------------	
	#
	#check if the directory tmpSysIdentStore already exist, if not create one, if so throw an error
	#
	#------------------------------------------------------------------------------------
	if
	  ModelPack:-DirExists(dirName)
	then
	  error("temporary directory %1 needed to run the procedure ReduceModel already exists. Please rename.", dirName)
	else  
          mkdir(dirName)
	end if:

	DDASPKproc := DDASPKSen:-CreateInstance(aDAESys, dirName, senPars, 'adifor'):

        #-------------------------------------------------------------------------------------------
	#
	#check if optional parameter is used, and has the right format, check additional conditions
	#
	#-------------------------------------------------------------------------------------------
	if
	  (nargs = 11)
	then
	  inputFct :=  args[11];
	  errorList :=  listOfErrorsInInputList( aDAESys, startTime, inputFct);
	  if not
	    errorList=[]
	  then
	    errorMsg :=  convert(errorList, string);
	    error(errorMsg);
	  end if:

	else
	  inputFct := [];
	end if:

	#------------------------------------------------------------------------------------	
	#
	#check if nrParamToRemove is smaller than the number of sensitivity Params in the DAESys
	#
	#------------------------------------------------------------------------------------	
	if
	  nrParamToRemove>nrParams
	then
	  error("The 8th parameter, %1, cannot be larger than the number of elements in the 7th parameter, %2.",nrParamToRemove, senPars);
	end if:

	#------------------------------------------------------------------------------------	
	#
	#calculate ODESolSen for the aDAESys from the input with senPars as Sensitivity Parameters
	#
	#------------------------------------------------------------------------------------

	#
	#check if variable input is used
	#
	if
	  inputFct=[]
	then
	  #
	  #without variable input
	  #
	  ODESolSen :=  CreateODESolSen(DDASPKproc,
	    DDASPKsenRepeats,
	    endTime ,
	    interval,
	    startTime,
	    initVars,	      
	    scaled
	  ):	  
	else
	  #
	  #with variable input
	  #
	  ODESolSen :=  CreateODESolSen(DDASPKproc,
	    DDASPKsenRepeats,
	    endTime ,
	    interval,
	    startTime,
	    initVars,
	    scaled,
	    inputFct
	  );
	end if:

	#------------------------------------------------------------------------------------		
	#
	#initialize the hessian once for all parameters, here we need a loop over all
	#variables TO DO
	#
	#------------------------------------------------------------------------------------
	resultListDegenring1:=[];
	resultListDegenring2:=[];
	resultListDegenring3:=[];

	for i from 1 to nops(varsList) do:
	  actVars:=varsList[i];
	  actOutputList:= [y1=actVars];
          actHessian :=  CreateHessianForSelectedParameters(ODESolSen,
	    varsList,
	    senPars,
	    startTime,
	    endTime,
	    actOutputList
	  );

	  #
	  #create a sorted list of the eigenvalues and the eigenvectors, because linalg doesn't sort its output
	  #
	  eigenvectorsAndEigenvaluesOfHessian :=  [linalg[eigenvectors](actHessian)];
	  eigenvalues:= convert([seq(eigenvectorsAndEigenvaluesOfHessian[i][1],i=1..nops(eigenvectorsAndEigenvaluesOfHessian))],
	    Vector
	  );
	  sortedEigenvectorsAndEigenvalues:= sort( eigenvectorsAndEigenvaluesOfHessian, firstListNumericElementIsSmaller);
	  allSortedEigenvectors:=[];
	  sortedEigenvalues:=[];
	  for h from 1 to nops(sortedEigenvectorsAndEigenvalues) do
	    actItem:= sortedEigenvectorsAndEigenvalues[h][3];
	    actEigenvalue:=sortedEigenvectorsAndEigenvalues[h][1];
	    if
	      nops(actItem)=1  
	    then		   
	      allSortedEigenvectors:= [op(allSortedEigenvectors),convert(op(actItem),list)];
	      sortedEigenvalues:= [op(sortedEigenvalues), actEigenvalue];
	    else
	      #
	      #insert the multiple eigenvectors seperatly into the list allSortedEigenvectorsAndEigenvalues
	      #
	      for m from 1 to nops(actItem) do:
	        actEigenvector:=actItem[m];
	        allSortedEigenvectors:=[op(allSortedEigenvectors),convert(op(actEigenvector),list)];
	        sortedEigenvalues:=[op(sortedEigenvalues), actEigenvalue];
	      end do:
	    end if:
	  end do:

	  sortedEigenvalues:= convert(sortedEigenvalues, Vector);
	  allSortedEigenvectorsMatrix:= convert(allSortedEigenvectors,Matrix);
	  allSortedEigenvectorsMatrix:= LinearAlgebra[Transpose](allSortedEigenvectorsMatrix);

	  #----------------------------------------------------------------------
	  #
	  #collect the results of the actual degenring steps
	  #
	  #----------------------------------------------------------------------

	  actOptions:=["number",nrParamToRemove];
	  degenring1List:=FindDegenringParameters(allSortedEigenvectorsMatrix,
	    sortedEigenvalues,
	    senPars,
	    1,
	    actOptions
	  );
	  resultListDegenring1:=[op(resultListDegenring1), degenring1List];

	  degenring2List:=FindDegenringParameters(allSortedEigenvectorsMatrix,
	    sortedEigenvalues,
	    senPars,
	    2,
	    actOptions
	  );
	  resultListDegenring2:=[op(resultListDegenring2), degenring2List];

	  degenring3List:=FindDegenringParameters(allSortedEigenvectorsMatrix,
	    sortedEigenvalues,
	    senPars,
	    3,
	    actOptions
	  );
	  resultListDegenring3:=[op(resultListDegenring3), degenring3List];
 	  #DEBUG();
	end do:
	#----------------------------------------------------------------------
	#
	#calculate the intersection of all results
	#
	#----------------------------------------------------------------------
        #intersectDegenring1:=`intersect`(seq(
	#  convert(degenring1List[i],set),
	#  i=1..nops(degenring1List)
	#));
        #intersectDegenring2:=`intersect`(seq(
	#  convert(degenring2List[i],set),
	#  i=1..nops(degenring2List)
	#));
        #intersectDegenring3:=`intersect`(seq(
	#  convert(degenring3List[i],set),
	#  i=1..nops(degenring3List)
	#));
	#result:=`intersect`(intersectDegenring1, intersectDegenring2, intersectDegenring3);
	#return result;
	result := [resultListDegenring1,resultListDegenring2,resultListDegenring3]:
	return result:
      end proc:

      ##################################################################################################################
      # input: aDAESys -> DAE system of interest; has to be of type DAESys
      #	       DDASPKsenRepeats -> Defines the number of integration repetitions for DDASPKsen
      #	       endTime -> right border of integration
      #	       startTime -> left border of integration   
      #	       interval -> disctance between points within the integration interval
      #	       initVars -> list of the Variables at start time -> start values for the variables used to solve the DAESys
      #	       senPars -> list containing the sensitivity parameter
      #	       calcPrecicion -> integer that fixes the precision of the calculation via Digit
      #	       dirName -> string that defines, where to store the DDASPKsen instance
      #	       scaled -> if true => scaling is applied to the sensitivities        
      #	       optional parameter -> inputFct, list of changing values of the input function
      # output: tuple: 1: list of parameter names to remove 2: list of lists with indices of paramters, that where chosen in one step
      #	comment: here one assumes, that a complete ranking of the parameters is desired => the nr of parameter to remove in the
      #		 findDegenringParameters routinge is equal to the number of parameters
      ##################################################################################################################
      FindParametersWithCompleteDegenringApproachV2:= proc(aDAESys::DAESys,
        DDASPKsenRepeats::integer,
	endTime::numeric,
	startTime::numeric,
	interval::numeric,
	initVars::list(numeric),
	senPars::list(name),
	calcPrecision::integer,
	dirName::string,
	scaled::boolean
	#optional input: inputFct::list([numeric,numeric])
      )
	local varsList,nrParams, DDASPKproc, inputFct, errorList, errorMsg, ODESolSen, resultListDegenring1, resultListDegenring2, resultListDegenring3,
	  i,actVars, actOutputList, actHessian, eigenvectorsAndEigenvaluesOfHessian, eigenvalues, sortedEigenvectorsAndEigenvalues,
	  allSortedEigenvectors, sortedEigenvalues, h, actItem, actEigenvalue, m, actEigenvector, actOptions, degenring1List, degenring2List,
	  degenring3List, intersectDegenring1, intersectDegenring2, intersectDegenring3, result, allSortedEigenvectorsMatrix, flagList, counter,
	  actParameterNr, actIntersect1, actIntersect2, actIntersect3, actIntersect, resultSet, actItemList, result2;


	#
	#set precision
	#
	Digits:=calcPrecision;
	#------------------------------------------------------------------------------------	
	#
	#define important variables
	#
	#------------------------------------------------------------------------------------					
	varsList:= aDAESys[DynVars];
	nrParams:=nops(senPars);

  	#------------------------------------------------------------------------------------	
	#
	#check if the directory tmpSysIdentStore already exist, if not create one, if so throw an error
	#
	#------------------------------------------------------------------------------------
	if
	  ModelPack:-DirExists(dirName)
	then
	  error("temporary directory %1 needed to run the procedure ReduceModel already exists. Please rename.", dirName)
	else  
          mkdir(dirName)
	end if:

	DDASPKproc := DDASPKSen:-CreateInstance(aDAESys, dirName, senPars, 'adifor'):

        #-------------------------------------------------------------------------------------------
	#
	#check if optional parameter is used, and has the right format, check additional conditions
	#
	#-------------------------------------------------------------------------------------------
	if
	  (nargs = 11)
	then
	  inputFct :=  args[11];
	  errorList :=  listOfErrorsInInputList( aDAESys, startTime, inputFct);
	  if not
	    errorList=[]
	  then
	    errorMsg :=  convert(errorList, string);
	    error(errorMsg);
	  end if:

	else
	  inputFct := [];
	end if:

	#------------------------------------------------------------------------------------	
	#
	#calculate ODESolSen for the aDAESys from the input with senPars as Sensitivity Parameters
	#
	#------------------------------------------------------------------------------------

	#
	#check if variable input is used
	#
	if
	  inputFct=[]
	then
	  #
	  #without variable input
	  #
	  ODESolSen :=  CreateODESolSen(DDASPKproc,
	    DDASPKsenRepeats,
	    endTime ,
	    interval,
	    startTime,
	    initVars,	      
	    scaled
	  ):	  
	else
	  #
	  #with variable input
	  #
	  ODESolSen :=  CreateODESolSen(DDASPKproc,
	    DDASPKsenRepeats,
	    endTime ,
	    interval,
	    startTime,
	    initVars,
	    scaled,
	    inputFct
	  );
	end if:

	#------------------------------------------------------------------------------------		
	#
	#initialize the hessian once for all parameters, 
	#
	#------------------------------------------------------------------------------------
	resultListDegenring1:=[];
	resultListDegenring2:=[];
	resultListDegenring3:=[];

	for i from 1 to nops(varsList) do:
	  actVars:=varsList[i];
	  actOutputList:= [y1=actVars];
          actHessian :=  CreateHessianForSelectedParameters(ODESolSen,
	    varsList,
	    senPars,
	    startTime,
	    endTime,
	    actOutputList
	  );

	  #------------------------------------------------------------------------------------		
	  #
	  #create a sorted list of the eigenvalues and the eigenvectors, because linalg doesn't sort its output
	  #
	  #------------------------------------------------------------------------------------		

	  eigenvectorsAndEigenvaluesOfHessian :=  [linalg[eigenvectors](actHessian)];
	  eigenvalues:= convert([seq(eigenvectorsAndEigenvaluesOfHessian[i][1],i=1..nops(eigenvectorsAndEigenvaluesOfHessian))],
	    Vector
	  );
	  sortedEigenvectorsAndEigenvalues:= sort( eigenvectorsAndEigenvaluesOfHessian, firstListNumericElementIsSmaller);
	  allSortedEigenvectors:=[];
	  sortedEigenvalues:=[];
	  for h from 1 to nops(sortedEigenvectorsAndEigenvalues) do
	    actItem:= sortedEigenvectorsAndEigenvalues[h][3];
	    actEigenvalue:=sortedEigenvectorsAndEigenvalues[h][1];
	    if
	      nops(actItem)=1  
	    then		   
	      allSortedEigenvectors:= [op(allSortedEigenvectors),convert(op(actItem),list)];
	      sortedEigenvalues:= [op(sortedEigenvalues), actEigenvalue];
	    else
	      #
	      #insert the multiple eigenvectors seperatly into the list allSortedEigenvectorsAndEigenvalues
	      #
	      actItemList:=[];

	      #
	      #convert all eigenvectors to list
	      #
	      for m from 1 to nops(actItem) do:
	        actEigenvector:=actItem[m];
		actItemList:=[op(actItemList), convert(actEigenvector,list)];
	        sortedEigenvalues:=[op(sortedEigenvalues), actEigenvalue];
	      end do:
	      actItemList:=sort(actItemList,ListNumericIsLarger);
	      allSortedEigenvectors:=[op(allSortedEigenvectors),op(actItemList)];
	    end if:
	  end do:
	  sortedEigenvalues:= convert(sortedEigenvalues, Vector);
	  allSortedEigenvectorsMatrix:= convert(allSortedEigenvectors,Matrix);
	  allSortedEigenvectorsMatrix:= LinearAlgebra[Transpose](allSortedEigenvectorsMatrix);

	  #----------------------------------------------------------------------
	  #
	  #collect the results of the actual degenring steps
	  #
	  #----------------------------------------------------------------------

	  actOptions:=["number",nops(senPars)];
	  degenring1List:=FindDegenringParameters(allSortedEigenvectorsMatrix,
	    sortedEigenvalues,
	    senPars,
	    1,
	    actOptions
	  );
	  resultListDegenring1:=[op(resultListDegenring1), degenring1List];

	  degenring2List:=FindDegenringParameters(allSortedEigenvectorsMatrix,
	    sortedEigenvalues,
	    senPars,
	    2,
	    actOptions
	  );
	  resultListDegenring2:=[op(resultListDegenring2), degenring2List];

	  degenring3List:=FindDegenringParameters(allSortedEigenvectorsMatrix,
	    sortedEigenvalues,
	    senPars,
	    3,
	    actOptions
	  );
	  resultListDegenring3:=[op(resultListDegenring3), degenring3List];

	end do:

	#----------------------------------------------------------------------
	#
	#Create the ranking by filling the result list until all parameters are
	#represented
	#
	#----------------------------------------------------------------------
	result:=[];
	result2:=[];
	flagList:=[];
	counter:=1;
	while nops(result)<nops(senPars) do:
	  actParameterNr:= nops(result);
	  actIntersect1:=`intersect`(seq(
	    convert(resultListDegenring1[i][1..counter],set),
	    i=1..nops(resultListDegenring1)
	  ));
	  actIntersect2:=`intersect`(seq(
	    convert(resultListDegenring2[i][1..counter],set),
	    i=1..nops(resultListDegenring2)
	  ));
	  actIntersect3:=`intersect`(seq(
	    convert(resultListDegenring3[i][1..counter],set),
	    i=1..nops(resultListDegenring3)
	  ));
	  actIntersect:=`intersect`(actIntersect1,actIntersect2,actIntersect3);

	  if not
	    actIntersect={}
	  then
	    #
	    #only add a new parameter, if this parameter is not already inlcuded
	    #
	    resultSet:=convert(result, set);
	    actIntersect:= actIntersect minus resultSet;
	    result:=[op(result), op(actIntersect)];
	    result2:=[op(result2), actIntersect];
	    
	  end if:
	  flagList:=[op(flagList),[counter,nops(actIntersect)]]; 
	  counter:= counter +1;	   
	end do:

	return [result,flagList, result2]:
      end proc:


      ##################################################################################################################
      # input: aDAESys -> DAE system of interest; has to be of type DAESys
      #	       DDASPKsenRepeats -> Defines the number of integration repetitions for DDASPKsen
      #	       endTime -> right border of integration
      #	       startTime -> left border of integration   
      #	       interval -> disctance between points within the integration interval
      #	       initVars -> list of the Variables at start time -> start values for the variables used to solve the DAESys
      #	       senPars -> list containing the sensitivity parameter
      #	       calcPrecicion -> integer that fixes the precision of the calculation via Digit
      #	       dirName -> string that defines, where to store the DDASPKsen instance
      #	       optional parameter -> inputFct, list of changing values of the input function
      #	       scaled -> if true => scaling is applied to the sensitivities        
      # output: tuple: 1: list of parameter names to remove 2: list of lists with indices of paramters, that where chosen in one step
      #	comment: here one assumes, that a complete ranking of the parameters is desired => in contrast to V2, here one iteratively
      #		 increases the number of parameters to be found be the FindDegenring subroutines, until a complete ranking is reached
      #	to do: the option that the trajectories and the sensitivities are computed without scaling is hardcoded
      ##################################################################################################################
      FindParametersWithCompleteDegenringApproachV3:= proc(aDAESys::DAESys,
        DDASPKsenRepeats::integer,
	endTime::numeric,
	startTime::numeric,
	interval::numeric,
	initVars::list(numeric),
	senPars::list(name),
	calcPrecision::integer,
	dirName::string,
	scaled::boolean
	#optional input: inputFct::list([numeric,numeric])
      )
	local varsList,nrParams, DDASPKproc, inputFct, errorList, errorMsg, ODESolSen, resultListDegenring1, resultListDegenring2, resultListDegenring3,
	  i,actVars, actOutputList, actHessian, eigenvectorsAndEigenvaluesOfHessian, eigenvalues, sortedEigenvectorsAndEigenvalues,
	  allSortedEigenvectors, sortedEigenvalues, h, actItem, actItemList,actEigenvalue, m, actEigenvector, actOptions, degenring1List, degenring2List,
	  degenring3List, actDegenring1List, actDegenring2List, actDegenring3List, allSortedEigenvectorsMatrix, flagList, actParameterNr,
	  actIntersect, resultParameter, intersectOverAllVars, listOfIntersectsForAllVars, listOfIntersectsPerVar, j, newParameters,
	  arrayOfAllEigenvectorsAndEigenvalues, allEigenvectorEigenvalueTupel, result2, counter, actEigenvectorsMatrix, actEigenvalues;


	#
	#set precision
	#
	Digits:=calcPrecision;
	#------------------------------------------------------------------------------------	
	#
	#define important variables
	#
	#------------------------------------------------------------------------------------					
	varsList:= aDAESys[DynVars];
	nrParams:=nops(senPars);

  	#------------------------------------------------------------------------------------	
	#
	#check if the directory tmpSysIdentStore already exist, if not create one, if so throw an error
	#
	#------------------------------------------------------------------------------------
	if
	  ModelPack:-DirExists(dirName)
	then
	  error("temporary directory %1 needed to run the procedure ReduceModel already exists. Please rename.", dirName)
	else  
          mkdir(dirName)
	end if:

	DDASPKproc := DDASPKSen:-CreateInstance(aDAESys, dirName, senPars, 'adifor'):

        #-------------------------------------------------------------------------------------------
	#
	#check if optional parameter is used, and has the right format, check additional conditions
	#
	#-------------------------------------------------------------------------------------------
	if
	  (nargs = 11)
	then
	  inputFct :=  args[11];
	  errorList :=  listOfErrorsInInputList( aDAESys, startTime, inputFct);
	  if not
	    errorList=[]
	  then
	    errorMsg :=  convert(errorList, string);
	    error(errorMsg);
	  end if:

	else
	  inputFct := [];
	end if:

	#------------------------------------------------------------------------------------	
	#
	#calculate ODESolSen for the aDAESys from the input with senPars as Sensitivity Parameters
	#
	#------------------------------------------------------------------------------------

	#
	#check if variable input is used
	#
	if
	  inputFct=[]
	then
	  #
	  #without variable input
	  #
	  ODESolSen :=  CreateODESolSen(DDASPKproc,
	    DDASPKsenRepeats,
	    endTime ,
	    interval,
	    startTime,
	    initVars,	      
	    scaled
	  ):	  
	else
	  #
	  #with variable input
	  #
	  ODESolSen :=  CreateODESolSen(DDASPKproc,
	    DDASPKsenRepeats,
	    endTime ,
	    interval,
	    startTime,
	    initVars,
	    scaled,
	    inputFct
	  );
	end if:

	arrayOfAllEigenvectorsAndEigenvalues:=array(1..nops(varsList));
	#------------------------------------------------------------------------------------		
	#
	#fill the eigenvectors, and values of the hessian for each variable into the arrayOfAllHessian to reduce runtime
	#
	#------------------------------------------------------------------------------------
	for i from 1 to nops(varsList) do:
	  actVars:=varsList[i];
	  actOutputList:= [y1=actVars];
	  actHessian :=  CreateHessianForSelectedParameters(ODESolSen,
	    varsList,
	    senPars,
	    startTime,
	    endTime,
	    actOutputList
	  );

	  #------------------------------------------------------------------------------------		
	  #
	  #create a sorted list of the eigenvalues and the eigenvectors, because linalg doesn't sort its output
	  #
	  #------------------------------------------------------------------------------------		

	  eigenvectorsAndEigenvaluesOfHessian :=  [linalg[eigenvectors](actHessian)];
	  eigenvalues:= convert([seq(eigenvectorsAndEigenvaluesOfHessian[i][1],i=1..nops(eigenvectorsAndEigenvaluesOfHessian))],
	    Vector
	  );
	  sortedEigenvectorsAndEigenvalues:= sort( eigenvectorsAndEigenvaluesOfHessian, firstListNumericElementIsSmaller);
	  allSortedEigenvectors:=[];
	  sortedEigenvalues:=[];
	  for h from 1 to nops(sortedEigenvectorsAndEigenvalues) do:
	    actItem:= sortedEigenvectorsAndEigenvalues[h][3];
	    actEigenvalue:=sortedEigenvectorsAndEigenvalues[h][1];
	    if
	      nops(actItem)=1  
	    then		   
	      allSortedEigenvectors:= [op(allSortedEigenvectors),convert(op(actItem),list)];
	      sortedEigenvalues:= [op(sortedEigenvalues), actEigenvalue];
	    else
	      #
	      #insert the multiple eigenvectors seperatly into the list allSortedEigenvectorsAndEigenvalues
	      #
	      actItemList:=[];
	      for m from 1 to nops(actItem) do:
	        actEigenvector:=actItem[m];
		actItemList:=[op(actItemList),convert(actEigenvector,list)];
		sortedEigenvalues:=[op(sortedEigenvalues), actEigenvalue];
	      end do:
	      actItemList:=sort(actItemList,ListNumericIsLarger);
	      allSortedEigenvectors:=[op(allSortedEigenvectors),op(actItemList)];
	    end if:
	  end do:

	  sortedEigenvalues:= convert(sortedEigenvalues, Vector);
	  allSortedEigenvectorsMatrix:= convert(allSortedEigenvectors,Matrix);
	  allSortedEigenvectorsMatrix:= LinearAlgebra[Transpose](allSortedEigenvectorsMatrix);
	  allEigenvectorEigenvalueTupel:=[allSortedEigenvectorsMatrix, sortedEigenvalues];
	  arrayOfAllEigenvectorsAndEigenvalues[i]:=allEigenvectorEigenvalueTupel;

	  #################
	  

	end do:

	#####################################################################################################
	#####################################################################################################
	#		DEBUG Comment:									    #	
	#		duration time in the MAPKinase model is about 7h				    #   
	#####################################################################################################
	#####################################################################################################

	#------------------------------------------------------------------------------------		
	#
	#initialize the hessian once for all parameters, 
	#
	#------------------------------------------------------------------------------------
	resultParameter:=[];
	result2:=[];
	flagList:=[];

	listOfIntersectsForAllVars:=[];
	counter:=1;

	while nops(resultParameter) < nops(senPars) do:
	  print(counter);
	  actOptions:=["number",counter];
	  listOfIntersectsPerVar:=[];
	  #DEBUG();
	  for i from 1 to nops(varsList) do:
	    
	    #----------------------------------------------------------------------
	    #
	    #calculate the Degenring parameters  defined by the iteration j
	    #
	    #----------------------------------------------------------------------
	    actEigenvectorsMatrix:= arrayOfAllEigenvectorsAndEigenvalues[i][1];
	    actEigenvalues:= arrayOfAllEigenvectorsAndEigenvalues[i][2];
	    actDegenring1List:=FindDegenringParameters(actEigenvectorsMatrix,
	      actEigenvalues,
	      senPars,
	      1,
	      actOptions
	    );
	    actDegenring2List:=FindDegenringParameters(actEigenvectorsMatrix,
	      actEigenvalues,
	      senPars,
	      2,
	      actOptions
	    );
	    actDegenring3List:=FindDegenringParameters(actEigenvectorsMatrix,
	      actEigenvalues,
	      senPars,
	      3,
	      actOptions
	    );
	    actIntersect:= `intersect`(convert(actDegenring1List,set),
	      convert(actDegenring2List,set),
	      convert(actDegenring3List,set)
	    );
	    listOfIntersectsPerVar:= [op(listOfIntersectsPerVar),actIntersect];
	  end do:

	  #-----------------------------------------------------------------------------------
	  #
	  #intersect over all parameters, and fill the results into the resultParameter list
	  #
	  #-----------------------------------------------------------------------------------
	  intersectOverAllVars:=`intersect`(seq(
	    listOfIntersectsPerVar[i],
	    i=1..nops(listOfIntersectsPerVar)
	  ));
	  print(intersectOverAllVars);

	  if not
	    intersectOverAllVars={}
	  then
	    newParameters:= intersectOverAllVars minus convert(resultParameter,set);
	    print(newParameters, resultParameter);
	    resultParameter:=[op(resultParameter), op(newParameters)];
	    result2:=[op(result2), newParameters];
	  else
	    newParameters:={};
	  end if:
	  #
	  #flag steps, that lead to the inclusion of more than one parameter to the result list
	  #
	  flagList:=[op(flagList),[counter,nops(newParameters)]];
	  counter:= counter +1;
	end do:  
	return [resultParameter,flagList,result2]:
      end proc:

      ##################################################################################################################
      # input: listA-> list(numeric) of length n
      #	       listB-> list(numeric) of length n
      # output: true if A is larger than B, else false
      #	comment: sorting criterion is 1) the length of the vectors, corresponding to the lists, and if the length is equal
      #		 2) first component is compared, the larger one wins, if equal, the second component is selected ...
      ##################################################################################################################
      ListNumericIsLarger:= proc(listA::list(numeric),
        listB::list(numeric)
      )
	local isLarger, vecA, vecB, normA, normB, i ,elementA, elementB;

	vecA:=convert(listA,Vector);
	vecB:=convert(listB,Vector);
	
	if not
	  LinearAlgebra[Dimension](vecA) = LinearAlgebra[Dimension](vecA)
	then
	  error("the lists to compare, have to have the same lenght");
	end if:

	normA:= evalf(LinearAlgebra[VectorNorm](vecA,Euclidean));
	normB:= evalf(LinearAlgebra[VectorNorm](vecB,Euclidean));
	if
	  listA=listB
	then
	  isLarger:=true:
	else
	  normA:= evalf(LinearAlgebra[VectorNorm](vecA,Euclidean));
 	  normB:= evalf(LinearAlgebra[VectorNorm](vecB,Euclidean));
	    if
	      normA>normB
	    then
	      isLarger:= true;

	    #
	    #special case, here the norm is equal => do a componentwise comparison, the vector with the first larger element is defined
	    #as larger
	    #
	    elif
	      normA=normB
	    then

	      for i from 1 to nops(listA) do:
		elementA:= listA[i];
		elementB:= listB[i];
		if
		  elementA>elementB
		then
		  isLarger:=true;
		  break:
		elif
		  elementA<elementB
		then
		  isLarger:=false:
		  break:
		end if
	      end do:

	    else
	      isLarger:=false;
	    end if:
	    
	end if:    

	return isLarger:
      end proc:

      ##################################################################################################################
      # input: aDAESys -> DAE system of interest; has to be of type DAESys
      #	       DDASPKsenRepeats -> Defines the number of integration repetitions for DDASPKsen
      #	       endTime -> right border of integration
      #	       startTime -> left border of integration   
      #	       interval -> disctance between points within the integration interval
      #	       initVars -> list of the Variables at start time -> start values for the variables used to solve the DAESys
      #	       senPars -> list containing the sensitivity parameter
      #	       calcPrecicion -> integer that fixes the precision of the calculation via Digit
      #	       dirName -> string that defines, where to store the DDASPKsen instance
      #	       optional parameter -> inputFct, list of changing values of the input function
      #	       scaled -> if true => scaling is applied to the sensitivities        
      # output: tuple: 1: list of parameter names to remove 2: list of lists with indices of paramters, that where chosen in one step
      #	comment: here one assumes, that a complete ranking of the parameters is desired => in contrast to V2, here one iteratively
      #		 increases the number of parameters to be found be the FindDegenring subroutines, until a complete ranking is reached
      #	to do: the option that the trajectories and the sensitivities are computed without scaling is hardcoded
      ##################################################################################################################
      FindParametersWithCompleteDegenringApproachV3_Array:= proc(aDAESys::DAESys,
        DDASPKsenRepeats::integer,
	endTime::numeric,
	startTime::numeric,
	interval::numeric,
	initVars::list(numeric),
	senPars::list(name),
	calcPrecision::integer,
	dirName::string,
	scaled::boolean
	#optional input: inputFct::list([numeric,numeric])
      )
	local varsList,nrParams, DDASPKproc, inputFct, errorList, errorMsg, ODESolSen, resultListDegenring1, resultListDegenring2, resultListDegenring3,
	  i,actVars, actOutputList, actHessian, eigenvectorsAndEigenvaluesOfHessian, eigenvalues, sortedEigenvectorsAndEigenvalues,
	  allSortedEigenvectors, sortedEigenvalues, h, actItem, actItemList,actEigenvalue, m, actEigenvector, actOptions, degenring1List, degenring2List,
	  degenring3List, actDegenring1List, actDegenring2List, actDegenring3List, allSortedEigenvectorsMatrix, flagList, actParameterNr,
	  actIntersect, resultParameter, intersectOverAllVars, listOfIntersectsForAllVars, listOfIntersectsPerVar, j, newParameters,
	  arrayOfAllEigenvectorsAndEigenvalues, allEigenvectorEigenvalueTupel, result2, counter, actEigenvectorsMatrix, actEigenvalues, iterationCounter,
	  actNumberOfEigenvectors, n, arrayOfIntersectsPerVar;


	#
	#set precision
	#
	Digits:=calcPrecision;
	#------------------------------------------------------------------------------------	
	#
	#define important variables
	#
	#------------------------------------------------------------------------------------					
	varsList:= aDAESys[DynVars];
	nrParams:=nops(senPars);

  	#------------------------------------------------------------------------------------	
	#
	#check if the directory tmpSysIdentStore already exist, if not create one, if so throw an error
	#
	#------------------------------------------------------------------------------------
	if
	  ModelPack:-DirExists(dirName)
	then
	  error("temporary directory %1 needed to run the procedure ReduceModel already exists. Please rename.", dirName)
	else  
          mkdir(dirName)
	end if:

	DDASPKproc := DDASPKSen:-CreateInstance(aDAESys, dirName, senPars, 'adifor'):

        #-------------------------------------------------------------------------------------------
	#
	#check if optional parameter is used, and has the right format, check additional conditions
	#
	#-------------------------------------------------------------------------------------------
	if
	  (nargs = 11)
	then
	  inputFct :=  args[11];
	  errorList :=  listOfErrorsInInputList( aDAESys, startTime, inputFct);
	  if not
	    errorList=[]
	  then
	    errorMsg :=  convert(errorList, string);
	    error(errorMsg);
	  end if:

	else
	  inputFct := [];
	end if:

	#------------------------------------------------------------------------------------	
	#
	#calculate ODESolSen for the aDAESys from the input with senPars as Sensitivity Parameters
	#
	#------------------------------------------------------------------------------------

	#
	#check if variable input is used
	#
	if
	  inputFct=[]
	then
	  #
	  #without variable input
	  #
	  ODESolSen :=  CreateODESolSen(DDASPKproc,
	    DDASPKsenRepeats,
	    endTime ,
	    interval,
	    startTime,
	    initVars,	      
	    scaled
	  ):	  
	else
	  #
	  #with variable input
	  #
	  ODESolSen :=  CreateODESolSen(DDASPKproc,
	    DDASPKsenRepeats,
	    endTime ,
	    interval,
	    startTime,
	    initVars,
	    scaled,
	    inputFct
	  );
	end if:

	arrayOfAllEigenvectorsAndEigenvalues:=array(1..nops(varsList));
	#------------------------------------------------------------------------------------		
	#
	#fill the eigenvectors, and values of the hessian for each variable into the arrayOfAllHessian to reduce runtime
	#
	#------------------------------------------------------------------------------------
	for i from 1 to nops(varsList) do:
	  actVars:=varsList[i];
	  actOutputList:= [y1=actVars];
	  actHessian :=  CreateHessianForSelectedParameters(ODESolSen,
	    varsList,
	    senPars,
	    startTime,
	    endTime,
	    actOutputList
	  );

	  #------------------------------------------------------------------------------------		
	  #
	  #create a sorted list of the eigenvalues and the eigenvectors, because linalg doesn't sort its output
	  #
	  #------------------------------------------------------------------------------------		
	  eigenvectorsAndEigenvaluesOfHessian :=  [linalg[eigenvectors](actHessian)];
	  eigenvalues:= convert([seq(eigenvectorsAndEigenvaluesOfHessian[i][1],i=1..nops(eigenvectorsAndEigenvaluesOfHessian))],
	    Vector
	  );
	  sortedEigenvectorsAndEigenvalues:= sort( eigenvectorsAndEigenvaluesOfHessian, firstListNumericElementIsSmaller);
	  allSortedEigenvectors:=array(1..nops(senPars));
	  sortedEigenvalues:=Vector(nops(senPars));
	  #
	  #different to iterator h from the loop, because there >= eigenvectors, than entries in sortedEigenvectorsAndEigenvalues
	  #because eigenvectors with the same eigenvalue are listed in the same entry
	  #
	  iterationCounter:=1;
	  for h from 1 to nops(sortedEigenvectorsAndEigenvalues) do
	    actItem:= sortedEigenvectorsAndEigenvalues[h][3];
	    actEigenvalue:=sortedEigenvectorsAndEigenvalues[h][1];
	    if
	      nops(actItem)=1  
	    then		   
	      allSortedEigenvectors[h]:= convert(op(actItem),list);
	      sortedEigenvalues[iterationCounter]:= actEigenvalue;
	      iterationCounter:=iterationCounter+1;
	    else
	      #
	      #insert the multiple eigenvectors seperatly into the list allSortedEigenvectorsAndEigenvalues
	      #
	      actItemList:=[];
	      actNumberOfEigenvectors:= nops(actItem);
	      for m from 1 to actNumberOfEigenvectors do:
	         actEigenvector:=actItem[m];
		 actItemList:=[op(actItemList),convert(actEigenvector,list)];
		 sortedEigenvalues[iterationCounter]:= actEigenvalue;
		 iterationCounter:=iterationCounter+1;
	      end do:
	      actItemList:=sort(actItemList,ListNumericIsLarger);
	      for n from 0 to nops(actItemList)-1 do:
	        allSortedEigenvectors[iterationCounter-(nops(actItemList)-i)]:=op(actItemList);
	      end do:				
	    end if:
	  end do:

	  allSortedEigenvectorsMatrix:= convert(allSortedEigenvectors,Matrix);
	  allSortedEigenvectorsMatrix:= LinearAlgebra[Transpose](allSortedEigenvectorsMatrix);
	  allEigenvectorEigenvalueTupel:=[allSortedEigenvectorsMatrix, sortedEigenvalues];
	  arrayOfAllEigenvectorsAndEigenvalues[i]:=allEigenvectorEigenvalueTupel;
	  #
	  #test for memory optimization
	  #
#	  gc();	   
        end do:

	#####################################################################################################
	#####################################################################################################
	#		DEBUG Comment:									    #	
	#		duration time in the MAPKinase model is about 7h				    #   
	#####################################################################################################
	#####################################################################################################

	#------------------------------------------------------------------------------------		
	#
	#initialize the hessian once for all parameters, 
	#
	#------------------------------------------------------------------------------------
	resultParameter:=[];
	result2:=[];
	flagList:=[];

	counter:=1;

	while nops(resultParameter) < nops(senPars) do:
	  actOptions:=["number",counter];
	  arrayOfIntersectsPerVar:=array(1..nops(varsList));

	  for i from 1 to nops(varsList) do:
	    
	    #----------------------------------------------------------------------
	    #
	    #calculate the Degenring parameters  defined by the iteration j
	    #
	    #----------------------------------------------------------------------
	    actEigenvectorsMatrix:= arrayOfAllEigenvectorsAndEigenvalues[i][1];
	    actEigenvalues:= arrayOfAllEigenvectorsAndEigenvalues[i][2];
	    actDegenring1List:=FindDegenringParametersOpt(actEigenvectorsMatrix,
	      actEigenvalues,
	      senPars,
	      1,
	      actOptions
	    );
	    actDegenring2List:=FindDegenringParametersOpt(actEigenvectorsMatrix,
	      actEigenvalues,
	      senPars,
	      2,
	      actOptions
	    );
	    actDegenring3List:=FindDegenringParametersOpt(actEigenvectorsMatrix,
	      actEigenvalues,
	      senPars,
	      3,
	      actOptions
	    );
	    actIntersect:= `intersect`(convert(actDegenring1List,set),
	      convert(actDegenring2List,set),
	      convert(actDegenring3List,set)
	    );
	    arrayOfIntersectsPerVar[i]:= actIntersect;
	  end do:

	  #-----------------------------------------------------------------------------------
	  #
	  #intersect over all parameters, and fill the results into the resultParameter list
	  #
	  #-----------------------------------------------------------------------------------
	  intersectOverAllVars:=`intersect`(seq(
	    arrayOfIntersectsPerVar[i],
	    i=1..nops(varsList)
	  ));

	  if not
	    intersectOverAllVars={}
	  then
	    newParameters:= intersectOverAllVars minus convert(resultParameter,set);
	    print(newParameters, resultParameter);
	    resultParameter:=[op(resultParameter), op(newParameters)];
	    result2:=[op(result2), newParameters];
	  else
	    newParameters:={};
	  end if:
	  #
	  #flag steps, that lead to the inclusion of more than one parameter to the result list
	  #
	  flagList:=[op(flagList),[counter,nops(newParameters)]];
	  counter:= counter +1;
	end do:  
	return [resultParameter,flagList,result2]:
      end proc:


      ##################################################################################################################
      # input: eigenvectorMatrix -> real matrix, each column contains an eigenvector, the first column represents,
      #				    the eigenvector with smallest eigenvalue, the second column represents the
      #				    eigenvector with second smallest eigenvalue and so on...
      #	       eigenvalues -> eigenvalues (sorted), corresponding to the eigenvectors in the eigenvectorMatrix		    
      #	       parameterList -> list of parameterNames corresponding to the eigenvector Matrix, dimension has to match the
      #				the eigenvectorMatrix dimension
      #	       mode -> 1,2 and 3, correspond to the different modes described in Degenring 2004, pp 375, section 3.3
      #	       removalNr -> sets the number of parameters that should be removed. 
      # output: list of parameters to remove; criterions for removal are taken from Degenring 2004			 
      # optimization steps: 1) turn removal list into an array
      #			    2) remove threshold option
      ##################################################################################################################
      FindDegenringParametersOptOpt:= proc(eigenvectorMatrix::Matrix,
        eigenvalues::Vector,
        parameterList::list(name),
	mode::integer,
	removalNr::integer
      )

	local nrParams, matrixDimension, actParam, i, actEigenvector, actEigenvectorMatrix, removalList, actParToRemove, thresholdIterator,
	  maxAbsResult, actRemovalIndex,k, actValues, j, actRowDimension, mode3Vector,actRow,sortedMaxResults,nrEigenvalues, actParameterList,
	  legalOptionNames, optionName, optionValue, threshold;

	nrParams:=nops(parameterList);
	matrixDimension:= op(1,eigenvectorMatrix)[1];
	removalList:=Array(1..nrParams);
	actParameterList:=parameterList;

	#--------------------------------------------------------------------------------
	#
	#check the input parameters
	#
	#--------------------------------------------------------------------------------

	#
	#check if removal nr is between 0 and nops(parameterList)
	#
	if not
	  (removalNr<=nops(parameterList) and removalNr>0)
	then
	  error("The third parameter: %1 has to be between 1 and %2", removalNr, nops(parameterList));
	end if;


	#
	#check if the dimensions of the eigenvectorMatrix corresponds to the dimension of nrParams
	#
	if not
	  nrParams=matrixDimension
	then
	  error("Dimension of first parameter: %1, and the third parameter: %2, do not match",matrixDimension, nrParams);
	end if;

	#
	#check if the dimensions of the eigenvectorMatrix corresponds to the dimension of eigenvalues
	#
	nrEigenvalues:=LinearAlgebra[Dimension](eigenvalues);
	if not
	  matrixDimension=nrEigenvalues
	then
	  error("Dimension of first parameter: %1, and second parameter %2, do not match",matrixDimension, nrEigenvalues);
	end if;

	#
	#check if eigenvalues is ordered
	#
	if not
	  ListTools[Sorted](convert(eigenvalues,list))
	then
	  error("The second parameter: %1, has to be a sorted vector.",eigenvalues);
	end if:  
	  
	#
	#check if mode is element {1,2,3}
	#
	if not
	  mode in {1,2,3}
	then
	  error("The mode parameter: %1, has to be element of the set {1,2,3}",mode);
	end if:

	#--------------------------------------------------------------------------------
	#
	#select the parameters from parameterList, in the order as they should be removed
	#
	#--------------------------------------------------------------------------------
	actEigenvectorMatrix:=eigenvectorMatrix;
	if
	  mode =1
	then
	  for i from 1 to removalNr do:
	    actEigenvector:= LinearAlgebra[Column](actEigenvectorMatrix,i);	  

	    maxAbsResult:=FindMaxAbsInVector(actEigenvector,1);    #FindMaxAbsInVector returns list[[value, position]]
	    actRemovalIndex:= maxAbsResult[1][2];
	    actParToRemove:=actParameterList[actRemovalIndex];
	    actParameterList:=subsop(actRemovalIndex = NULL,actParameterList);
	    removalList[i]:=actParToRemove;

	    #remove the corresponding row from the actEigenvector for the next round
	    actEigenvectorMatrix:=LinearAlgebra[DeleteRow](actEigenvectorMatrix, actRemovalIndex);
	  end do:

        elif
	  mode =3
	then
	  for i from 1 to (nops(parameterList)-removalNr) do:
	    actEigenvector:= LinearAlgebra[Column](actEigenvectorMatrix,-i);
	    maxAbsResult:=FindMaxAbsInVector(actEigenvector,1);    #FindMaxAbsInVector returns list[[value, position]]
	    actRemovalIndex:= maxAbsResult[1][2];
	    actParToRemove:=actParameterList[actRemovalIndex];
	    actParameterList:=subsop(actRemovalIndex = NULL,actParameterList);
	    removalList[i]:=actParToRemove;

	    #remove the corresponding row from the actEigenvector for the next round
	    actEigenvectorMatrix:=LinearAlgebra[DeleteRow](actEigenvectorMatrix, actRemovalIndex);
	  end do:
	  removalList:=array(actParameterList);

	elif
	  mode=2
	then
	  actEigenvectorMatrix:=LinearAlgebra[DeleteColumn](eigenvectorMatrix,(removalNr+1)..-1);
	  #
	  #calculate the squared sum over the rows for each row
	  #
	  actRowDimension:=LinearAlgebra[Dimension](actEigenvectorMatrix)[1];
	  mode3Vector:=Vector[column](actRowDimension);
	  for i from 1 to actRowDimension do:
	    actRow:=LinearAlgebra[Row](actEigenvectorMatrix,i);
	    mode3Vector[i]:= actRow.actRow;      
	  end do:
	  sortedMaxResults:=FindMaxAbsInVector(mode3Vector, op(1,mode3Vector));

	  for j from 1 to removalNr do:
	    actRemovalIndex:=sortedMaxResults[1][2];
	    actParToRemove:=actParameterList[actRemovalIndex];
	    removalList[j]:=actParToRemove;
	    sortedMaxResults:=subsop(1=NULL, sortedMaxResults);
	  end do:
	end if:
	
	return convert(removalList,list);

      end proc:

      ##################################################################################################################
      # input: aDAESys -> DAE system of interest; has to be of type DAESys
      #	       DDASPKsenRepeats -> Defines the number of integration repetitions for DDASPKsen
      #	       endTime -> right border of integration
      #	       startTime -> left border of integration   
      #	       interval -> disctance between points within the integration interval
      #	       initVars -> list of the Variables at start time -> start values for the variables used to solve the DAESys
      #	       senPars -> list containing the sensitivity parameter
      #	       calcPrecicion -> integer that fixes the precision of the calculation via Digit
      #	       dirName -> string that defines, where to store the DDASPKsen instance
      #	       optional parameter -> inputFct, list of changing values of the input function
      #	       scaled -> if true => scaling is applied to the sensitivities        
      # output: tuple: 1: list of parameter names to remove 2: list of lists with indices of paramters, that where chosen in one step
      #	comment: here one assumes, that a complete ranking of the parameters is desired => in contrast to V2, here one iteratively
      #		 increases the number of parameters to be found be the FindDegenring subroutines, until a complete ranking is reached
      #	to do: the option that the trajectories and the sensitivities are computed without scaling is hardcoded
      ##################################################################################################################
      FindParametersWithCompleteDegenringApproachV3_Opt:= proc(aDAESys::DAESys,
        DDASPKsenRepeats::integer,
	endTime::numeric,
	startTime::numeric,
	interval::numeric,
	initVars::list(numeric),
	senPars::list(name),
	calcPrecision::integer,
	dirName::string,
	scaled::boolean
	#optional input: inputFct::list([numeric,numeric])
      )
	local varsList,nrParams, DDASPKproc, inputFct, errorList, errorMsg, ODESolSen, resultListDegenring1, resultListDegenring2, resultListDegenring3,
	  i,actVars, actOutputList, actHessian, eigenvectorsAndEigenvaluesOfHessian, eigenvalues, sortedEigenvectorsAndEigenvalues,
	  allSortedEigenvectors, sortedEigenvalues, h, actItem, actItemList,actEigenvalue, m, actEigenvector, actOptions, degenring1List, degenring2List,
	  degenring3List, actDegenring1List, actDegenring2List, actDegenring3List, allSortedEigenvectorsMatrix, flagList, actParameterNr,
	  actIntersect, resultParameter, intersectOverAllVars, listOfIntersectsForAllVars, listOfIntersectsPerVar, j, newParameters,
	  arrayOfAllEigenvectorsAndEigenvalues, allEigenvectorEigenvalueTupel, result2, counter, actEigenvectorsMatrix, actEigenvalues,
	  iteratedIntersectArray, actSortedEigenvectors, actSortedEigenvalues, iterationCounter, actNumberOfEigenvectors, actSortedEigenvectorsMatrix,
	  selectionCounter, arrayOfIntersectPerVar;


	#
	#set precision
	#
	Digits:=calcPrecision;
	#------------------------------------------------------------------------------------	
	#
	#define important variables
	#
	#------------------------------------------------------------------------------------					
	varsList:= aDAESys[DynVars];
	nrParams:=nops(senPars);

  	#------------------------------------------------------------------------------------	
	#
	#check if the directory tmpSysIdentStore already exist, if not create one, if so throw an error
	#
	#------------------------------------------------------------------------------------
	if
	  ModelPack:-DirExists(dirName)
	then
	  error("temporary directory %1 needed to run the procedure ReduceModel already exists. Please rename.", dirName)
	else  
          mkdir(dirName)
	end if:

	DDASPKproc := DDASPKSen:-CreateInstance(aDAESys, dirName, senPars, 'adifor'):

        #-------------------------------------------------------------------------------------------
	#
	#check if optional parameter is used, and has the right format, check additional conditions
	#
	#-------------------------------------------------------------------------------------------
	if
	  (nargs = 11)
	then
	  inputFct :=  args[11];
	  errorList :=  listOfErrorsInInputList( aDAESys, startTime, inputFct);
	  if not
	    errorList=[]
	  then
	    errorMsg :=  convert(errorList, string);
	    error(errorMsg);
	  end if:

	else
	  inputFct := [];
	end if:

	#------------------------------------------------------------------------------------	
	#
	#calculate ODESolSen for the aDAESys from the input with senPars as Sensitivity Parameters
	#
	#------------------------------------------------------------------------------------

	#
	#check if variable input is used
	#
	if
	  inputFct=[]
	then
	  #
	  #without variable input
	  #
	  ODESolSen :=  CreateODESolSen(DDASPKproc,
	    DDASPKsenRepeats,
	    endTime ,
	    interval,
	    startTime,
	    initVars,	      
	    scaled
	  ):	  
	else
	  #
	  #with variable input
	  #
	  ODESolSen :=  CreateODESolSen(DDASPKproc,
	    DDASPKsenRepeats,
	    endTime ,
	    interval,
	    startTime,
	    initVars,
	    scaled,
	    inputFct
	  );
	end if:

	#------------------------------------------------------------------------------------		
	#
	#store the 2 Dimensional array iteratedIntersectArray, for all Variables, a list of
	#all intersects with increasing i in ["number",i] in FindDegenringParameters 
	#
	#------------------------------------------------------------------------------------	
	iteratedIntersectArray:=Array(1..nops(varsList), 1..nops(senPars));


	#------------------------------------------------------------------------------------	
	#
	#loop over all variables
	#
	#------------------------------------------------------------------------------------	
	for i from 1 to nops(varsList) do:
	  actVars:=varsList[i];
	  actOutputList:= [y1=actVars];
	  actHessian :=  CreateHessianForSelectedParameters(ODESolSen,
	    varsList,
	    senPars,
	    startTime,
	    endTime,
	    actOutputList
	  );

	  #------------------------------------------------------------------------------------		
	  #
	  #create a sorted list of the eigenvalues and the eigenvectors, because linalg doesn't sort its output
	  #
	  #------------------------------------------------------------------------------------		
	  eigenvectorsAndEigenvaluesOfHessian :=  [linalg[eigenvectors](actHessian)];
	  eigenvalues:= convert([seq(eigenvectorsAndEigenvaluesOfHessian[i][1],i=1..nops(eigenvectorsAndEigenvaluesOfHessian))],
	    Vector
	  );
	  sortedEigenvectorsAndEigenvalues:= sort( eigenvectorsAndEigenvaluesOfHessian, firstListNumericElementIsSmaller);
	  actSortedEigenvectors:=[];
	  actSortedEigenvalues:=Vector(nops(senPars));
	  #
	  #introduction of iterationCounter: different to iterator h from the loop, because there >= eigenvectors
	  #than entries in sortedEigenvectorsAndEigenvalues
	  #because eigenvectors with the same eigenvalue are listed in the same entry
	  #
	  iterationCounter:=1;
	  for h from 1 to nops(sortedEigenvectorsAndEigenvalues) do
	    actItem:= sortedEigenvectorsAndEigenvalues[h][3];
	    actEigenvalue:=sortedEigenvectorsAndEigenvalues[h][1];
	    if
	      nops(actItem)=1  
	    then		   
	      actSortedEigenvectors:= [op(actSortedEigenvectors),convert(op(actItem),list)];
	      actSortedEigenvalues[iterationCounter]:= actEigenvalue;
	      iterationCounter:=iterationCounter+1;
	    else
	      #
	      #insert the multiple eigenvectors seperatly into the list actSortedEigenvectorsAndEigenvalues
	      #
	      actItemList:=[];
	      actNumberOfEigenvectors:= nops(actItem);
	      for m from 1 to actNumberOfEigenvectors do:
	         actEigenvector:=actItem[m];
		 actItemList:=[op(actItemList),convert(actEigenvector,list)];
		 actSortedEigenvalues[iterationCounter]:= actEigenvalue;
		 iterationCounter:=iterationCounter+1;
	      end do:
	      actItemList:=sort(actItemList,ListNumericIsLarger);
	      actSortedEigenvectors:=[op(actSortedEigenvectors),op(actItemList)];
	    end if:
	  end do:

	  actSortedEigenvectorsMatrix:= convert(actSortedEigenvectors,Matrix);
	  actSortedEigenvectorsMatrix:= LinearAlgebra[Transpose](actSortedEigenvectorsMatrix);
	  
	  #------------------------------------------------------------------------------------	
	  #
	  #loop over all parameters
	  #
	  #------------------------------------------------------------------------------------	
	  for j from 1 to nops(senPars) do:
	    #actOptions:=["number", j];

	    #------------------------------------------------------------------------------------	
	    #
	    #calculate the degenring solution (with all 3 variants) and build the intersects of
	    #the variants
	    #
	    #------------------------------------------------------------------------------------	

	    actDegenring1List:=FindDegenringParametersOptOpt(actSortedEigenvectorsMatrix,
	      actSortedEigenvalues,
	      senPars,
	      1,
	      j
	      #actOptions
	    );
	    actDegenring2List:=FindDegenringParametersOptOpt(actSortedEigenvectorsMatrix,
	      actSortedEigenvalues,
	      senPars,
	      2,
	      j
	      #actOptions
	    );
	    actDegenring3List:=FindDegenringParametersOptOpt(actSortedEigenvectorsMatrix,
	      actSortedEigenvalues,
	      senPars,
	      3,
	      j
	      #actOptions
	    );
	    actIntersect:= `intersect`(convert(actDegenring1List,set),
	      convert(actDegenring2List,set),
	      convert(actDegenring3List,set)
	    );
	    iteratedIntersectArray[i,j]:= actIntersect;

	  end do:

	end do:  
        #------------------------------------------------------------------------------------	
	#
	#end filling of iteratedIntersectArray
	#
	#------------------------------------------------------------------------------------	

	#------------------------------------------------------------------------------------	
	#
	#start intersecting all solutions, until a final ranking is created, that integrate
	#all methods and the different hessians(regarding the variables)
	#
	#------------------------------------------------------------------------------------	
	resultParameter:=[];
	result2:=[];
	flagList:=[];

	for selectionCounter from 1 to nops(senPars) do:

          if
	    nops(resultParameter)=nops(senPars)
	  then
	    break;
	  end if:

	  arrayOfIntersectPerVar:=array(1..nops(varsList));

	  #-----------------------------------------------------------------------------------
	  #
	  #intersect over all variables and record the results. Collect the choosen parameters,
	  #and look in the iteratedIntersectArray in the next level
	  #
	  #-----------------------------------------------------------------------------------
	  intersectOverAllVars:=`intersect`(seq(
	    iteratedIntersectArray[i,selectionCounter],
	    i=1..nops(varsList)
	  ));

	  if not
	    intersectOverAllVars={}
	  then
	    newParameters:= intersectOverAllVars minus convert(resultParameter,set);
	    print(newParameters, resultParameter);
	    resultParameter:=[op(resultParameter), op(newParameters)];
	    result2:=[op(result2), newParameters];
	  else
	    newParameters:={};
	  end if:
	  #
	  #flag steps, that lead to the inclusion of more than one parameter to the result list
	  #
	  flagList:=[op(flagList),[selectionCounter,nops(newParameters)]];
	  counter:= counter +1;
        end do:
        return [resultParameter, result2, flagList];

      end proc:


      ##################################################################################################################
      # input: DDASPKproc -> module of type DDASPKSen
      #	       trajeSens -> module of type Curve, has to be created with function CreateODESolSen, if scaling is used,
      #			    has already been decided in the trajeSen object
      #        endTime -> right border of integration
      #        startTime -> left border of integration      
      #	       varsList -> for checking if the right variables are contained in trajeSens
      #	       senParsList -> selection of Parameters, for which the sensitivities should be selected
      #	       outputFnctList::list(equation) -> list of equations of the output
      #	       cutOff -> numeric; as described in Yao 2003 p 571
      # output: list of parameters to remove; criterions for removal are taken from Yao 2003
      #	to do: define a checking function for trajeSen, or declare this function only to be used "private" => usage is
      #	       guaranteed to be correct
      #	to do: make sure, that not the same parameters are removed again and again
      # comment: optimizing with defining squaredXMatrix as symmetric was not so effecitve. Here it is ommited. In the optimized
      #		 version it will be included
      ##################################################################################################################
      FindYaoParameter:= proc(DDASPKproc::`module`,
	trajeSens::`module`,
	endTime::numeric,
	startTime::numeric,
	varsList::list(name),
	senParsList::list(name),
	outputFunctionList::list(equation),
        cutOff::numeric	
      )

        local data,sizeTrajeSens, nrVars, nrParams, nrFnct, initTime, allParams, allParameterNames, zMatrix, zRoofMatrix, paramToRemove, listOfColumns,
	columnNormList, columnNormVector, maxValueAndPosition, maxColumnPosition, maxColumn, xMatrix, controlSet, i, transposedXMatrix, squaredXMatrix,
	preMatrix, rMatrix, actListOfColumns, actColumnNormList, actColumnNormVector, actMaxValueAndPosition, actMaxColumnPosition, actMaxColumnValue,
	secondColumnPosition, secondColumnValue, actMaxColumn, rank;

        #
        #define important variables
        #
        data:= trajeSens:-GetData();
        sizeTrajeSens:=trajeSens:-GetNumPoints();
        nrVars := nops(varsList);
        nrParams:= nops(senParsList);
        nrFnct := nops(outputFnctList);
        initTime:= data[time][1];
        allParams:=trajeSens:-GetParameters();
        allParameterNames:=map(lhs,allParams);      
  
        #------------------------------------------------------------------------------------	
        #
        #create the z matrix; z matrix is the same as the g matrix in Zak 2003 => we can apply
        #the method CalculateGMatrix
        #
        #------------------------------------------------------------------------------------
        zMatrix:=CalculateGMatrix(DDASPKproc,
          trajeSens,
          startTime,	
   	  endTime,
  	  varsList,
  	  senParsList,
          outputFunctionList
        );
        #
        #initialize the zRoofMatrix and the xMatrix (as introduced in Yao 2003)
        #
        zRoofMatrix:=zMatrix;
	rank:= LinearAlgebra[Rank](zMatrix);
	print("Rank of sensitivity matrix: ", rank); 
  
        #----------------------------------------------------------------------------------------------------
        #
        #until the cut off value is met do the calculation
        #
        #----------------------------------------------------------------------------------------------------
        paramToRemove:=[];
        #
        #select initial parameter to remove
        #
        listOfColumns:= [LinearAlgebra[Column](zMatrix, 1..nrParams)];
        columnNormList:=[seq(
	  sqrt(LinearAlgebra[DotProduct](listOfColumns[i], listOfColumns[i])),
	  i=1..nrParams
        )];
        columnNormVector:=convert(columnNormList,Vector);
        maxValueAndPosition:=FindMaxAbsInVector(columnNormVector,4);
	print(seq(senParsList[maxValueAndPosition[i][2]],i=1..4),
	  seq(maxValueAndPosition[i][1], i=1..4)
	);
        maxColumnPosition:=maxValueAndPosition[1][2];     #due to the outputformat of FindMaxAbsInVector one has to asses the first element first
        maxColumn:= LinearAlgebra[Column](zMatrix,maxColumnPosition);
        paramToRemove:=[op(paramToRemove),senParsList[maxColumnPosition]];
        xMatrix:=maxColumn;

        controlSet:=[maxColumnPosition];

        for i from 1 to nrParams do:
          #----------------------------------------------------------------------------------------------------
	  #
	  #1) calculate the columnNorm of the actual zRoofMatrix 
	  #2) create the xMatrix (Yao 2003)
	  #3) calculate zRoofMatrix
	  #
	  #----------------------------------------------------------------------------------------------------

	  #
	  #calculate the preMatrix, that is multiplied with z to get zRoof Yao2003 p 571 step 4 second line
 	  #
	  transposedXMatrix:= LinearAlgebra[Transpose](xMatrix);
	  squaredXMatrix:=evalf(LinearAlgebra[Multiply](transposedXMatrix,xMatrix));


	  #only in the first iteration preMatrix is a scalar
	  if not
	    i = 1
	  then
    	    try
  	      preMatrix:= LinearAlgebra[MatrixInverse](squaredXMatrix):
  	    catch "singular matrix":
  	      print(lasterror):
	      break;
  	    end try:
	    preMatrix:=LinearAlgebra[Multiply](xMatrix,preMatrix);
	    preMatrix:=LinearAlgebra[Multiply](preMatrix, transposedXMatrix);
	  else
	    preMatrix:=1/squaredXMatrix;
	    preMatrix:=preMatrix.transposedXMatrix;
	    preMatrix:=LinearAlgebra[Multiply](xMatrix,preMatrix);
	  end if:
	  #
	  #calculate zRoof
 	  #
	  zRoofMatrix:= LinearAlgebra[Multiply](preMatrix, zMatrix);

	  #
	  #calculate rMatrix, of residuals
 	  #  
	  rMatrix:= zMatrix - zRoofMatrix;

	  #print the linear dependence of the lastly selected parameter; should be very small near 0
	  print(LinearAlgebra[Norm](rMatrix[1..nrParams,controlSet[-1]], Euclidean));

	  #
	  #determine the column of rMatrix with largest sum of squares
	  #
	  actListOfColumns:= [LinearAlgebra[Column](rMatrix, 1..nrParams)];
	  actColumnNormList:=[seq(
	    sqrt(LinearAlgebra[DotProduct](actListOfColumns[i], actListOfColumns[i])),
	    i=1..nrParams
          )];
	  actColumnNormVector:=convert(actColumnNormList,Vector);
	  actMaxValueAndPosition:=FindMaxAbsInVector(actColumnNormVector,4);
	  print(seq(senParsList[actMaxValueAndPosition[i][2]],i=1..4),
	    seq(actMaxValueAndPosition[i][1], i=1..4)
	  );
	  actMaxColumnPosition:=actMaxValueAndPosition[1][2];
	  actMaxColumnValue:= actMaxValueAndPosition[1][1];
	  secondColumnPosition:= actMaxValueAndPosition[2][2];
	  secondColumnValue:= actMaxValueAndPosition[2][1];

	  #
	  #test for identical columns
	  #
	  
	  if
	    actMaxColumnValue = secondColumnValue	
	  then
	    print("In iteration 1% there are two alternatives: 2%", i, [senParsList[actMaxColumnPosition], senParsList[secondColumnPosition]]);
	  end if:


	  actMaxColumn:= LinearAlgebra[Column](zMatrix,actMaxColumnPosition);
	  print(actMaxColumnValue, senParsList[actMaxColumnPosition]);

	  #
	  #test if not the same parameter has been choosen
 	  #
	  if
	    actMaxColumnPosition in convert(controlSet,set)
	  then	
	    WARNING("function FindYaoParameter selected a parameter already choosen => select the parameter with second highest scored");
	    print("function FindYaoParameter selected a parameter already choosen => select the parameter with second highest scored");
	    #
	    #test the next top positions
	    #
	    for i from 2 to nrParams do:
	      actMaxValueAndPosition:=FindMaxAbsInVector(actColumnNormVector,i);		
	      actMaxColumnPosition:=actMaxValueAndPosition[i][2];
	      actMaxColumnValue:= actMaxValueAndPosition[i][1];
	      if not
	        actMaxColumnPosition in controlSet
	      then
	        controlSet:=[op(controlSet), actMaxColumnPosition];
	        break;
	      end if:				      
	    end do:

	  else
	    controlSet:=[op(controlSet), actMaxColumnPosition];
	  end if:

	  #	       
	  #test the cutOff criterion
 	  # 
	  if
	    (cutOff >= actMaxColumnValue)	
	  then
	    print("%1 is larger than cut off: %2",actMaxColumnValue, cutOff);
	    break;
	  end if:

	  paramToRemove:=[op(paramToRemove),senParsList[actMaxColumnPosition]];
	  xMatrix:=ArrayTools[Concatenate](2, xMatrix, actMaxColumn);
        end do:
        return paramToRemove:

      end proc:



      ##################################################################################################################
      # input: DDASPKproc -> module of type DDASPKSen
      #	       trajeSens -> module of type Curve, has to be created with function CreateODESolSen, if scaling is used,
      #			    has already been decided in the trajeSen object
      #        endTime -> right border of integration
      #        startTime -> left border of integration      
      #	       varsList -> for checking if the right variables are contained in trajeSens
      #	       senParsList -> selection of Parameters, for which the sensitivities should be selected
      #	       outputFnctList::list(equation) -> list of equations of the output
      #	       cutOff -> numeric; as described in Yao 2003 p 571
      # output: list of parameters to remove; criterions for removal are taken from Yao 2003
      #	to do: define a checking function for trajeSen, or declare this function only to be used "private" => usage is
      #	       guaranteed to be correct
      #	to do: make sure, that not the same parameters are removed again and again
      #	comment: here we use the structural information of the problem, to reuse information from Xj-1 in each iteration j for the
      #		 calculation of Xj
      #	optimiziation points: 1. declare the symmetric matrices as symmetric
      #			      2. reuse information from previous iterations
      #				 a) X*Z => only the last row has to be calculated
      #				 b) Xt*X => only the last row (identical to the last column) has to be calculated
      #
      # to do: exchange for loop with while loop, that terminates, when a complete ranking is achieved. (work around in the for loop
      #	       with -1)
      # to do: removed cutOff test, since it is irrelevant for our purposes
      ##################################################################################################################
      FindYaoParameterOpt:= proc(DDASPKproc::`module`,
	trajeSens::`module`,
	endTime::numeric,
	startTime::numeric,
	varsList::list(name),
	senParsList::list(name),
	outputFunctionList::list(equation),
        cutOff::numeric	
      )

        local data,sizeTrajeSens, nrVars, nrParams, nrFnct, initTime, allParams, allParameterNames, zMatrix, zRoofMatrix, paramToRemove, listOfColumns,
	columnNormList, columnNormVector, maxValueAndPosition, maxColumnPosition, maxColumn, xMatrix, controlSet, i, transposedXMatrix, squaredXMatrix,
	preMatrix, rMatrix, actListOfColumns, actColumnNormList, actColumnNormVector, actMaxValueAndPosition, actMaxColumnPosition, actMaxColumnValue,
	secondColumnPosition, secondColumnValue, actMaxColumn, rank, lastColumnOfZ, maxColumnValue, newColumn, newRow, subColumn, invSquaredXMatrix, transposedActMaxColumn, lastRow, XTransZ, tmpMatrix, j;

        #
        #define important variables
        #
        data:= trajeSens:-GetData();
        sizeTrajeSens:=trajeSens:-GetNumPoints();
        nrVars := nops(varsList);
        nrParams:= nops(senParsList);
        nrFnct := nops(outputFnctList);
        initTime:= data[time][1];
        allParams:=trajeSens:-GetParameters();
        allParameterNames:=map(lhs,allParams);      
  
        #------------------------------------------------------------------------------------	
        #
        #create the z matrix; z matrix is the same as the g matrix in Zak 2003 => we can apply
        #the method CalculateGMatrix
        #
        #------------------------------------------------------------------------------------
        zMatrix:=CalculateGMatrix(DDASPKproc,
          trajeSens,
          startTime,	
   	  endTime,
  	  varsList,
  	  senParsList,
          outputFunctionList
        );

	lastColumnOfZ:=LinearAlgebra[Column](zMatrix, -1);
        #
        #initialize the zRoofMatrix and the xMatrix (as introduced in Yao 2003)
        #
        zRoofMatrix:=zMatrix;
	rank:= LinearAlgebra[Rank](zMatrix);
	print("Rank of sensitivity matrix: ", rank); 
  
        #----------------------------------------------------------------------------------------------------
        #
        #until the cut off value is met do the calculation
        #
        #----------------------------------------------------------------------------------------------------
        paramToRemove:=[];
        #
        #select initial parameter to remove
        #
        listOfColumns:= [LinearAlgebra[Column](zMatrix, 1..nrParams)];
        columnNormList:=[seq(
	  sqrt(LinearAlgebra[DotProduct](listOfColumns[i], listOfColumns[i])),
	  i=1..nrParams
        )];
        columnNormVector:=convert(columnNormList,Vector);
        maxValueAndPosition:=FindMaxAbsInVector(columnNormVector,4);
	print(seq(senParsList[maxValueAndPosition[i][2]],i=1..4),
	  seq(maxValueAndPosition[i][1], i=1..4)
	);

        maxColumnPosition:=maxValueAndPosition[1][2];     #due to the outputformat of FindMaxAbsInVector one has to asses the first element first
	maxColumnValue:=maxValueAndPosition[1][1];
	maxColumn:= LinearAlgebra[Column](zMatrix,maxColumnPosition);
        paramToRemove:=[op(paramToRemove),senParsList[maxColumnPosition]];
        xMatrix:=maxColumn;
        controlSet:=[maxColumnPosition];
	print(maxColumnValue, senParsList[maxColumnPosition]);
	i:=1;
        while nops(paramToRemove)<= nrParams do:
	  
          #----------------------------------------------------------------------------------------------------
	  #
	  #1) calculate the columnNorm of the actual zRoofMatrix 
	  #2) create the xMatrix (Yao 2003)
	  #3) calculate zRoofMatrix
	  #
	  #----------------------------------------------------------------------------------------------------

	  #
	  #calculate the preMatrix, that is multiplied with z to get zRoof Yao2003 p 571 step 4 second line
 	  #
	  transposedXMatrix:= LinearAlgebra[Transpose](xMatrix);


	  #only in the first iteration preMatrix is a scalar
	  if not
	    (i = 1 or i=2 or i=3)
	  then
	    #
	    #stack together the squaredXMatrix from information of the last iteration
	    #only one column (the last) has to be calculated newly
	    #
	    newColumn:=LinearAlgebra[Multiply](transposedXMatrix, actMaxColumn);
	    newRow:=LinearAlgebra[Transpose](newColumn);
	    subColumn:=LinearAlgebra[SubVector](newColumn,1..-2);
	    squaredXMatrix:=ArrayTools[Concatenate](2, squaredXMatrix, subColumn);
	    squaredXMatrix:=ArrayTools[Concatenate](1, squaredXMatrix, newRow);
	    squaredXMatrix:=convert(squaredXMatrix, Matrix, shape=symmetric);
	    op(squaredXMatrix)[7];

	    #
	    #try to invert the squaredXMatrix
	    #
	    try
  	      invSquaredXMatrix:= LinearAlgebra[MatrixInverse](squaredXMatrix):
  	    catch "singular matrix":
	      print(lasterror);
  	      WARNING("%1",lasterror):
	      break;
  	    end try:

	    #
	    #stack together the XTrans*Z; here we only need to calculate the last row and the last column
	    #
	    #wrong# lastColumn:=LinearAlgebra[Multiply](transposedXMatrix, lastColumnOfZ);
	    #wrong# lastColumnMinusOne:=LinearAlgebra[SubVector](lastColumn, 1..-2);
	    transposedActMaxColumn:=LinearAlgebra[Transpose](actMaxColumn);
	    lastRow:= LinearAlgebra[Multiply](transposedActMaxColumn,zMatrix);

	    
	    #wrong# XTransZ:=ArrayTools[Concatenate](2, XTransZ, lastColumnMinusOne);
	    XTransZ:=ArrayTools[Concatenate](1, XTransZ, lastRow);

	    #
	    #calculate Z roof.
	    #
	    tmpMatrix:=LinearAlgebra[Multiply](invSquaredXMatrix, XTransZ);
	    zRoofMatrix:= LinearAlgebra[Multiply](xMatrix, tmpMatrix);

	  elif
	    i = 1
	  then
	    squaredXMatrix:=evalf(LinearAlgebra[Multiply](transposedXMatrix,xMatrix));
	    invSquaredXMatrix:=1/squaredXMatrix;
	    XTransZ:=LinearAlgebra[Multiply](transposedXMatrix, zMatrix);
	    tmpMatrix:=LinearAlgebra[Multiply](invSquaredXMatrix, XTransZ);
	    zRoofMatrix:= LinearAlgebra[Multiply](xMatrix,tmpMatrix);

	  #
	  # after second or third iteration
	  #
	  elif
	    i=2 or i=3
	  then  
	    squaredXMatrix:=evalf(LinearAlgebra[Multiply](transposedXMatrix,xMatrix));
	    #
	    #try to invert the squaredXMatrix
	    #
	    try
  	      invSquaredXMatrix:= LinearAlgebra[MatrixInverse](squaredXMatrix):
  	    catch "singular matrix":
	      print(lasterror);
  	      WARNING("%1",lasterror):
	      break;
  	    end try:
	    XTransZ:=LinearAlgebra[Multiply](transposedXMatrix, zMatrix);
	    tmpMatrix:=LinearAlgebra[Multiply](invSquaredXMatrix, XTransZ);
	    zRoofMatrix:= LinearAlgebra[Multiply](xMatrix,tmpMatrix);	    	    
	  end if:

	  #
	  #calculate rMatrix, of residuals
 	  #  
	  rMatrix:= zMatrix - zRoofMatrix;

	  #print the linear dependence of the lastly selected parameter; should be very small near 0
	  print(LinearAlgebra[Norm](rMatrix[1..nrParams,controlSet[-1]], Euclidean));

	  #
	  #determine the column of rMatrix with largest sum of squares
	  #
	  actListOfColumns:= [LinearAlgebra[Column](rMatrix, 1..nrParams)];
	  actColumnNormList:=[seq(
	    sqrt(LinearAlgebra[DotProduct](actListOfColumns[i], actListOfColumns[i])),
	    i=1..nrParams
          )];
	  actColumnNormVector:=convert(actColumnNormList,Vector);
	  actMaxValueAndPosition:=FindMaxAbsInVector(actColumnNormVector,4);
	  print(seq(senParsList[actMaxValueAndPosition[i][2]],i=1..4),
	    seq(actMaxValueAndPosition[i][1], i=1..4)
	  );
	  actMaxColumnPosition:=actMaxValueAndPosition[1][2];
	  actMaxColumnValue:= actMaxValueAndPosition[1][1];
	  secondColumnPosition:= actMaxValueAndPosition[2][2];
	  secondColumnValue:= actMaxValueAndPosition[2][1];

	  #
	  #test for identical columns
	  #
	  
	  if
	    actMaxColumnValue = secondColumnValue	
	  then
	    print("In iteration 1% there are two alternatives: 2%", i, [senParsList[actMaxColumnPosition], senParsList[secondColumnPosition]]);
	  end if:


	  actMaxColumn:= LinearAlgebra[Column](zMatrix,actMaxColumnPosition);
	  print(actMaxColumnValue, senParsList[actMaxColumnPosition]);

	  #
	  #test if not the same parameter has been choosen
 	  #
	  if
	    actMaxColumnPosition in convert(controlSet,set)
	  then	
	    WARNING("function FindYaoParameter selected a parameter already choosen => select the parameter with second highest scored");
	    print("function FindYaoParameter selected a parameter already choosen => select the parameter with second highest scored");
	    #
	    #test the next top positions
	    #
	    actMaxValueAndPosition:=FindMaxAbsInVector(actColumnNormVector,nrParams);
	    for j from 2 to nrParams do:
	      actMaxColumnPosition:=actMaxValueAndPosition[j][2];
	      actMaxColumnValue:= actMaxValueAndPosition[j][1];
	      if not
	        actMaxColumnPosition in controlSet
	      then
	        controlSet:=[op(controlSet), actMaxColumnPosition];
	        break;
	      end if:				      
	    end do:

	  else
	    controlSet:=[op(controlSet), actMaxColumnPosition];
	  end if:

	  #	       
	  #test the cutOff criterion
 	  # 
  	
	  if
	    (cutOff >= actMaxColumnValue)	
	  then
	    print("%1 is larger than cut off: %2",actMaxColumnValue, cutOff);
	    break;
	  end if:

	  paramToRemove:=[op(paramToRemove),senParsList[actMaxColumnPosition]];
	  xMatrix:=ArrayTools[Concatenate](2, xMatrix, actMaxColumn);
	  i:=i+1;

        end do:
        return paramToRemove:

      end proc:


#      ##################################################################################################################
#      # input: aDAESys ->DAE system of interest; has to be of type DAESys
#      #	       DDASPKsenRepeats -> Defines the number of integration repetitions for DDASPKSen
#      #	       endTime-> right border of integration
#      #	       startTime -> left border of integration = start condition for the solution of the DAESys
#      #	       interval -> disctance between points within the integration interval
#      #	       initVars -> list of the Variables at start time -> start values for the variables used to solve the DAESys
#      #	       senPars -> list containing the sensitivity parameter
#      #	       outputFnctList -> list of equations, containing the response functions (g(x(t)), p, u(t))
#      #	       calcPrecicion -> integer that fixes the precision of the calculation via Digit
#      #	       dirName -> string that defines, where to store the DDASPKsen instance
#      #	       scaled -> if true => the hessian is scaled as in Yao 2003 formula 6
#      #	       listOfReductionList -> list of lists containing parameter names. Each list specifies one reduction suggestion,
#      #				      made by the user.
#      # optional argument : inputFct -> list containing tupels: [time, newInput]. Each tupel describes the timepoint, when
#      #					 when the input should be changed, and the new value for the input
#      #	       			 
#      #
#      # output: List containing list of lists containing for each list specified in parameter 12
#      #				1) a list containing the removed parameters in the order of removal
#      #				2) a list of the smallest Eigenvalue of the Hessianmatrix in each reduction iteration
#      #				3) Hessian of the reduced Modell
#      ##################################################################################################################
#      ComputeHessianEigenvaluesForSelectedParameterst:= proc(aDAESys::DAESys,
#        DDASPKsenRepeats::integer,
#	endTime::numeric,
#	startTime::numeric,
#	interval::numeric,
#	initVars::list(numeric),
#	senPars::list(name),
#	outputFnctList::list(equation),
#	calcPrecision::integer,
#	dirName::string,
#	scaled::boolean,
#	listOfReductionList::list(list(name))
#	#optional input: inputFct::list([numeric,numeric])
#      )
#
#      	local varsList,matrixDimension, nrRowsGMatrix, correlationThreshold, correlationFlag, actCorrelationMatrix, maxCorrelationPositionAndValue,
#	  correlationValue ,ODESolSen, listOfModi, eValue, listOfRemovedParameter, inputFct, errorList, errorMsg, DDASPKproc,
#	  eigenvalues, allEigenvectors, smallestEigenvalueAndPosition, listOfSmallestEValues, eigenvectorWithSmallestEigenvalue,
#	  maxEntryAndPosition, actPosition, gMatrix, parameterCorrelationMatrix, i, j, actCorrelation, sumOfRows, paramToRemove,
#	  toReturn, actSenPars,iterationCounter, hessianMatrix, actHessian, eigenvectorsAndEigenvaluesOfHessian, positionOfSmallestEigenvector,
#	  smallestEigenvector, reductionList, sortedEigenvectorsAndEigenvalues, allSortedEigenvectors, sortedEigenvalues, allSortedEigenvectorsMatrix,
#	  degenringList, degenringIndexList, scalingFactor, actParam, h, actItem,actItemList, actEigenvalue, m, actEigenvector, degenringOpt, initTime;
#
#
#	#
#	#set precision
#	#
#	Digits:=calcPrecision;
#	#------------------------------------------------------------------------------------	
#	#
#	#define important variables
#	#
#	#------------------------------------------------------------------------------------					
#	eValue:=0;
#	listOfSmallestEValues:=[];
#	listOfRemovedParameter:=[];
#	varsList:= aDAESys[DynVars];
#
#  	#------------------------------------------------------------------------------------	
#	#
#	#check if the directory tmpSysIdentStore already exist, if not create one, if so throw an error
#	#
#	#------------------------------------------------------------------------------------
#	if
#	  ModelPack:-DirExists(dirName)
#	then
#	  error("temporary directory %1 needed to run the procedure ReduceModel already exists. Please rename.", dirName)
#	else  
#          mkdir(dirName)
#	end if:
#
#	DDASPKproc := DDASPKSen:-CreateInstance(aDAESys, dirName, senPars, 'adifor'):
#
#        #-------------------------------------------------------------------------------------------
#	#
#	#check if optional parameter is used, and has the right format, check additional conditions
#	#
#	#-------------------------------------------------------------------------------------------
#	if
#	  (nargs = 13)
#	then
#	  inputFct :=  args[13];
#	  errorList :=  listOfErrorsInInputList( aDAESys, startTime, inputFct);
#	  if not
#	    errorList=[]
#	  then
#	    errorMsg :=  convert(errorList, string);
#	    error(errorMsg);
#	  end if:
#
#	else
#	  inputFct := [];
#	end if:
#
#	#------------------------------------------------------------------------------------		
#	#
#	#check, that the elements in each listOfReductionList correlate to sensitivity
#	#Parameters (specified in senPars)
#	#
#	#------------------------------------------------------------------------------------	
#	for actList in listOfReductionList do:	
#	  # 
#	  #test if all parameters specified in the list are also contained in senPar
#	  #
#	  if not
#	    convert(actList,set) subset convert(senPars,set)
#	  then
#	    ERROR("The list in the 12th parameter: %1 , has to be a subset of %2", actList, senPars);
#	  end if:
#	end do:  
#
#	#------------------------------------------------------------------------------------	
#	#
#	#calculate ODESolSen for the aDAESys from the input with senPars as Sensitivity Parameters
#	#
#	#------------------------------------------------------------------------------------	
#	#
#	#check if variable input is used
#	#
#	if
#	  inputFct=[]
#	then
#	  #
#	  #without variable input
#	  #
#	 ODESolSen :=  CreateODESolSen(DDASPKproc,
#	   DDASPKsenRepeats,
#	   endTime ,
#	   interval,
#	   startTime,
#	   initVars,
#	   scaled
#	 ):
#	else
#	  #
#	  #with variable input
#	  #
#	  ODESolSen :=  CreateODESolSen(DDASPKproc,
#	    DDASPKsenRepeats,
#	    endTime ,
#	    interval,
#	    startTime,
#	    initVars,
#	    scaled,
#	    inputFct
#	  );
#
#	end if:
#
#	#------------------------------------------------------------------------------------		
#	#
#	#initialize the the hessian once for all parameters
#	#
#	#------------------------------------------------------------------------------------	
#        hessianMatrix :=  CreateHessianForSelectedParameters(ODESolSen,
#	  varsList,
#	  senPars,
#	  startTime,
#	  endTime,
#	  outputFnctList
#        );
#
#
#	#----------------------------------------------------------------------------------------------------
#	#
#	#reduce paramters in listOfReductionLists in one step
#	#
#	#----------------------------------------------------------------------------------------------------
#	toReturn:=[];
#	for i from 1 to nops(listOfReductionLists) do:
#	  sTime:=time();  
#	  print("iteration", iterationCounter);  
#	  actList:= listOfReductionLists;
#	  actHessian:=hessianMatrix;
#	  #
#	  #delete the rows and columns in actHessian corresponding to the elements in actLists
#	  #
#	  actPosition:=op(FindIndicesOfListElements([degenringList[1]], actSenPars));
#
#
#
#	  #
#	  #delete those rows and columns of the correlation Matrix, corresponding to removed parameters 
#	  #
#	  actPositionList:= FindIndicesOfListElements(actList, senPars)
#	  actHessian:=LinearAlgebra[DeleteColumn](actHessian,actPositionList);
#	  actHessian:=LinearAlgebra[DeleteRow](actHessian,actPositionList);
#	  actHessian:=Matrix(actHessian,shape=symmetric);
#
#	  #
#	  #calculate the eigenvectors and eigenvalues of the reduced systems
#	  #
#	  #
#
#	  #Eigenvectors returns a tupel of first a column vector containing the eigenvalues and then a matrix, where each column represents the
#	  #Eigenvector
#	  
#	  eigenvectorsAndEigenvaluesOfHessian :=  [linalg[eigenvectors](actHessian)];
#	  eigenvalues:= convert([seq(eigenvectorsAndEigenvaluesOfHessian[i][1],i=1..nops(eigenvectorsAndEigenvaluesOfHessian))],
#	    Vector
#	  );
#
#	  #
#	  #determine the smallest eigenvalue (the LinearAlgebara[Eigenvectors] methods returns them already sorted
#	  #
#	  smallestEigenvalueAndPosition:= FindMinAbsInVector(eigenvalues,1);
#	  eValue:=smallestEigenvalueAndPosition[1][1];
#	  listOfSmallestEValues:=[op(listOfSmallestEValues), eValue];##
#	  positionOfSmallestEigenvector:= smallestEigenvalueAndPosition[1][2];
#	  allEigenvectors:=[seq(op(eigenvectorsAndEigenvaluesOfHessian[i][3]),  
#	    i=1..nops(eigenvectorsAndEigenvaluesOfHessian)
#	  )];
#	  smallestEigenvector:= convert(allEigenvectors[positionOfSmallestEigenvector],Vector);
#
#	  actResult:=[actList listOfSmallestEValues, actHessian];
#
#	  #
#	  #store result in toReturn
#	  #
#	  toReturn:=[op(toReturn), actResult];
#	  print("Time for iteration", i, " is", time()-sTime );
#
#	end do:
#
#	return toReturn:
#
#      end proc:


end module: